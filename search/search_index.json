{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reelay Monitors Reelay is a header-only C++ library for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase. Features Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line Rye Format Reelay reads executable specifications written in plain text and verifies at runtime that the system does what those specifications describe. In order to construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Reelay Expression (Rye) format. See Rye format reference for more details. Get Started The next steps for you are to install Reelay from source code , pip , or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ and Python . Contribute Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment.","title":"Home"},{"location":"#reelay-monitors","text":"Reelay is a header-only C++ library for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase.","title":"Reelay Monitors"},{"location":"#features","text":"Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line","title":"Features"},{"location":"#rye-format","text":"Reelay reads executable specifications written in plain text and verifies at runtime that the system does what those specifications describe. In order to construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Reelay Expression (Rye) format. See Rye format reference for more details.","title":"Rye Format"},{"location":"#get-started","text":"The next steps for you are to install Reelay from source code , pip , or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ and Python .","title":"Get Started"},{"location":"#contribute","text":"Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment.","title":"Contribute"},{"location":"author/","text":"Dogan Ulus Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Author"},{"location":"author/#dogan-ulus","text":"Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Dogan Ulus"},{"location":"behaviors/","text":"Temporal Behaviors A temporal behavior of a system is a time-ordered sequence of observations regarding the system. There are two primary models of temporal behaviors we consider in Reelay: Discrete time behaviors Dense time behaviors The main distinction between two models for the user is how time progresses between two observations. For discrete time behaviors, time value increases exactly 1 time unit between two observations. For dense time behaviors, however, time can increase at arbitrary amounts including fractional values. In that case, an explicit timing information such as a timestamp is added to the observation data. In the following we use multiline JSON files to represent temporal behaviors to give examples and explain some important concepts. Discrete Time Behaviors and Persistence The multiline JSON document below represents a discrete time behavior where each JSON object containing three variables regarding a system. For discrete time behaviors the progression of time is implicit as time value increases one by one for each line starting from zero. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Start\" } // time: 1 { \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Start\" } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 4 ... Normally each temporal variable of the system is recorded in such JSON objects (or other equivalent representation) for each time point. Usually temporal variables do not change their value for every time point. Indeed they can have the same value for long time periods. This brings the concept of persistence for temporal behaviors. Persistence means that we interpret the value of temporal variables from the last time when they are set in the behavior. In other words, once a temporal variable set in the behavior, its value persists until it is set again. For example, the discrete time behavior above can be equivalently represented under persistance interpreation as below. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 } // time: 1 { \"speed\" : 19.12 } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 {} // time: 4 In Reelay we support persistent discrete time behaviors and indeed it is encouraged to use persistent behaviors for efficiency reasons. Finally notice that discrete time behaviors would contain sequences of empty JSON objects if no value changed from the previous time point (again a common case in real life systems). Monitors will be updated at each time point for the same values for a long time period, which is not very efficient. Here it is better to switch dense time model as we need to process many time points having the same value at once. Dense Time Behaviors Dense time behaviors contain extra timing information next to the observation data. In Reelay we reserve top-level time keyword for this purpose. This allows to represent temporal behaviors changing at irregular intervals and jump many time points at once. Dense time behaviors are naturally persistent, meaning that temporal variables retain their values for skipped times as in the discrete case. For example, suppose we have a dense time behavior as below: { \"time\" : 0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32 , \"speed\" : 19.12 } { \"time\" : 65 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100 } When a dense timed Reelay monitor processes such a temporal behavior, it calls its update method 5 times (1 for each JSON object) whereas a discrete timed monitor would need 100 calls. An update step of dense timed monitors is more expensive than that of discrete timed monitors but there is a point using dense time model becomes advantegous. Therefore, we provide both discrete and dense timed monitors in Reelay where the discrete model is better suited for fast and regularly updated systems and the dense model for slow and irregularly ones. Finally, since we no longer need to progress one-by-one, we can also progress smaller steps or fractional steps. Below is a dense time behavior using floating point numbers for time field. { \"time\" : 0.0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11.3 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32.1 , \"speed\" : 19.12 } { \"time\" : 65.13 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100.0 } And the user can select the base time type (currently only primitive types) for Reelay monitors depending on their system. Final remark This document aimed to give a practical view of temporal behaviors for the user rather than precise mathematical definitions of discrete and dense time behaviors. These definitions can be found at our paper .","title":"Temporal Behaviors"},{"location":"behaviors/#temporal-behaviors","text":"A temporal behavior of a system is a time-ordered sequence of observations regarding the system. There are two primary models of temporal behaviors we consider in Reelay: Discrete time behaviors Dense time behaviors The main distinction between two models for the user is how time progresses between two observations. For discrete time behaviors, time value increases exactly 1 time unit between two observations. For dense time behaviors, however, time can increase at arbitrary amounts including fractional values. In that case, an explicit timing information such as a timestamp is added to the observation data. In the following we use multiline JSON files to represent temporal behaviors to give examples and explain some important concepts.","title":"Temporal Behaviors"},{"location":"behaviors/#discrete-time-behaviors-and-persistence","text":"The multiline JSON document below represents a discrete time behavior where each JSON object containing three variables regarding a system. For discrete time behaviors the progression of time is implicit as time value increases one by one for each line starting from zero. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Start\" } // time: 1 { \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Start\" } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 4 ... Normally each temporal variable of the system is recorded in such JSON objects (or other equivalent representation) for each time point. Usually temporal variables do not change their value for every time point. Indeed they can have the same value for long time periods. This brings the concept of persistence for temporal behaviors. Persistence means that we interpret the value of temporal variables from the last time when they are set in the behavior. In other words, once a temporal variable set in the behavior, its value persists until it is set again. For example, the discrete time behavior above can be equivalently represented under persistance interpreation as below. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 } // time: 1 { \"speed\" : 19.12 } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 {} // time: 4 In Reelay we support persistent discrete time behaviors and indeed it is encouraged to use persistent behaviors for efficiency reasons. Finally notice that discrete time behaviors would contain sequences of empty JSON objects if no value changed from the previous time point (again a common case in real life systems). Monitors will be updated at each time point for the same values for a long time period, which is not very efficient. Here it is better to switch dense time model as we need to process many time points having the same value at once.","title":"Discrete Time Behaviors and Persistence"},{"location":"behaviors/#dense-time-behaviors","text":"Dense time behaviors contain extra timing information next to the observation data. In Reelay we reserve top-level time keyword for this purpose. This allows to represent temporal behaviors changing at irregular intervals and jump many time points at once. Dense time behaviors are naturally persistent, meaning that temporal variables retain their values for skipped times as in the discrete case. For example, suppose we have a dense time behavior as below: { \"time\" : 0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32 , \"speed\" : 19.12 } { \"time\" : 65 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100 } When a dense timed Reelay monitor processes such a temporal behavior, it calls its update method 5 times (1 for each JSON object) whereas a discrete timed monitor would need 100 calls. An update step of dense timed monitors is more expensive than that of discrete timed monitors but there is a point using dense time model becomes advantegous. Therefore, we provide both discrete and dense timed monitors in Reelay where the discrete model is better suited for fast and regularly updated systems and the dense model for slow and irregularly ones. Finally, since we no longer need to progress one-by-one, we can also progress smaller steps or fractional steps. Below is a dense time behavior using floating point numbers for time field. { \"time\" : 0.0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11.3 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32.1 , \"speed\" : 19.12 } { \"time\" : 65.13 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100.0 } And the user can select the base time type (currently only primitive types) for Reelay monitors depending on their system.","title":"Dense Time Behaviors"},{"location":"behaviors/#final-remark","text":"This document aimed to give a practical view of temporal behaviors for the user rather than precise mathematical definitions of discrete and dense time behaviors. These definitions can be found at our paper .","title":"Final remark"},{"location":"docker/","text":"Running Reelay in a Docker container This document is for people who want to try Reelay apps using a Docker container. If you haven't Docker engine installed on your machice, please follow the original instructions here . When Docker engine is installed, pull the latest docker image of Reelay and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then, inside the container, you can run the app ryjson1 that provides a command-line interface for Reelay monitors that checks multi-line JSON logs against Rye specifications. For example, ryjson1 -x '{p1} since[18:24] {p2}' examples.jsonl Please also check ryjson1 --help for further information on other flags and general usage.","title":"Docker Image"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is for people who want to try Reelay apps using a Docker container. If you haven't Docker engine installed on your machice, please follow the original instructions here . When Docker engine is installed, pull the latest docker image of Reelay and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then, inside the container, you can run the app ryjson1 that provides a command-line interface for Reelay monitors that checks multi-line JSON logs against Rye specifications. For example, ryjson1 -x '{p1} since[18:24] {p2}' examples.jsonl Please also check ryjson1 --help for further information on other flags and general usage.","title":"Running Reelay in a Docker container"},{"location":"gs_cpp/","text":"Getting Started From C++ In this part, we show how to instatiate and run Reelay monitors in C++ given formal specifications. These monitors would check the system behavior and report violations at runtime. If you have't already, please recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . Source files for this tutorial can be found here . Reelay Monitors The core component of Reelay is a header-only template library for C++ and can be included as follows. #include \"reelay/monitors.hpp\" In this tutorial we use options and make_monitor constructs to configure and make runtime monitors from our specifications. The library gives you some options to configure monitors. The first and most important configuration option is the time model where you select one Discrete timed model Dense timed model Normally you would select discrete timed model if you work on discrete time behaviors and dense timed model if dense time behaviors. This choice depends on on your system and needs. If you haven't already, please check the documentation on discrete and dense time behaviors before proceeding. Check Requirements over Discrete Time Behaviors In this section we demonstrate how to configure, build and run a discrete timed Reelay monitor. First, we create an options object as follows: auto opts = reelay :: discrete_timed < time_type > :: monitor < input_t , output_t >:: options () . disable_condensing () . with_value_field_name ( \"verdict\" ); Let's explain these options. As mentioned earlier, the first options says that we want a discrete timed monitor and we use time_type as the Since this is a discrete monitor, time_type must an integral number type, typically intmax_t . The second part sets input_t and output_t types of input and output types of our monitors. By default, set these types to reelay::json (alias to nlohmann::json ). For more advanced uses, the library allows you to use other (map-like) types if you provide some adapter/formatter classes. But, for now, use reelay::json . The remaining options controls the output of the monitor, which we will explain shortly. Once we have our opts object, we make our monitor from a specification as follows: std :: string pattern = \"(historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning}\" ; auto my_monitor_1 = reelay :: make_monitor ( pattern , opts ); Note that you can use the same opts to make different monitors with the same configuration. THen we can execute each monitor using update methods that accepts a single input_t objects. For example, if we are reading a JSON Lines logfile (opened as input_file ), we check the logfile line-by-line as follows: for ( std :: string line ; std :: getline ( input_file , line );) { reelay :: json message = reelay :: json :: parse ( line ); auto result1 = my_monitor_1 . update ( message ); if ( result1 [ \"verdict\" ] == false ) { std :: cout << \"Error at \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The output object result1 is a output_t object (here reelay::json) and verdict field (as set in opts ) would contain the monitor result at each time. Finally in this tutorial, since our requirements must be true for all time points, we print an error message if there is any violation. The complete source file of the discrete timed monitor of DOW warning tutorial can be found here . Check Requirements over Dense Time Behaviors In this section we demonstrate how to configure, build and run a dense timed Reelay monitor. Similar to the discrete monitors, we create an options object as follows: auto opts = reelay :: dense_timed < time_type > :: monitor < input_t , output_t >:: options () . with_time_field_name ( \"timestamp\" ) . with_value_field_name ( \"verdict\" ); Here we used dense_timed<time_type> construct to denote we want a dense timed monitor. Unlike discrete time monitors, here we can use floating types, typically double . After we set out input-output types, we make our dense timed monitors in the same way: std :: string pattern = \"(historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning}\" ; auto my_monitor_1 = reelay :: make_monitor ( pattern , opts ); The execution also works similar way; however, now notice that the output is a json::array in particular. This is due to the verdict can change multiple times between two updates as we progress in time at arbitrary amounts in dense timed model. In other words, our monitors outputs all changes between the last time and current time point. And if nothing changes the outputs would be just empty. Below is an example execution for dense timed monitors. for ( std :: string line ; std :: getline ( input_file , line );) { reelay :: json message = reelay :: json :: parse ( line ); auto r1 = my_monitor_1 . update ( message ); if ( not r1 . empty ()){ for ( const auto & segment : r1 ) { std :: cout << segment << std :: endl ; } } } The complete source file of the dense timed monitor of DOW warning tutorial can be found here .","title":"Use Reelay from C++"},{"location":"gs_cpp/#getting-started-from-c","text":"In this part, we show how to instatiate and run Reelay monitors in C++ given formal specifications. These monitors would check the system behavior and report violations at runtime. If you have't already, please recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . Source files for this tutorial can be found here .","title":"Getting Started From C++"},{"location":"gs_cpp/#reelay-monitors","text":"The core component of Reelay is a header-only template library for C++ and can be included as follows. #include \"reelay/monitors.hpp\" In this tutorial we use options and make_monitor constructs to configure and make runtime monitors from our specifications. The library gives you some options to configure monitors. The first and most important configuration option is the time model where you select one Discrete timed model Dense timed model Normally you would select discrete timed model if you work on discrete time behaviors and dense timed model if dense time behaviors. This choice depends on on your system and needs. If you haven't already, please check the documentation on discrete and dense time behaviors before proceeding.","title":"Reelay Monitors"},{"location":"gs_cpp/#check-requirements-over-discrete-time-behaviors","text":"In this section we demonstrate how to configure, build and run a discrete timed Reelay monitor. First, we create an options object as follows: auto opts = reelay :: discrete_timed < time_type > :: monitor < input_t , output_t >:: options () . disable_condensing () . with_value_field_name ( \"verdict\" ); Let's explain these options. As mentioned earlier, the first options says that we want a discrete timed monitor and we use time_type as the Since this is a discrete monitor, time_type must an integral number type, typically intmax_t . The second part sets input_t and output_t types of input and output types of our monitors. By default, set these types to reelay::json (alias to nlohmann::json ). For more advanced uses, the library allows you to use other (map-like) types if you provide some adapter/formatter classes. But, for now, use reelay::json . The remaining options controls the output of the monitor, which we will explain shortly. Once we have our opts object, we make our monitor from a specification as follows: std :: string pattern = \"(historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning}\" ; auto my_monitor_1 = reelay :: make_monitor ( pattern , opts ); Note that you can use the same opts to make different monitors with the same configuration. THen we can execute each monitor using update methods that accepts a single input_t objects. For example, if we are reading a JSON Lines logfile (opened as input_file ), we check the logfile line-by-line as follows: for ( std :: string line ; std :: getline ( input_file , line );) { reelay :: json message = reelay :: json :: parse ( line ); auto result1 = my_monitor_1 . update ( message ); if ( result1 [ \"verdict\" ] == false ) { std :: cout << \"Error at \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The output object result1 is a output_t object (here reelay::json) and verdict field (as set in opts ) would contain the monitor result at each time. Finally in this tutorial, since our requirements must be true for all time points, we print an error message if there is any violation. The complete source file of the discrete timed monitor of DOW warning tutorial can be found here .","title":"Check Requirements over Discrete Time Behaviors"},{"location":"gs_cpp/#check-requirements-over-dense-time-behaviors","text":"In this section we demonstrate how to configure, build and run a dense timed Reelay monitor. Similar to the discrete monitors, we create an options object as follows: auto opts = reelay :: dense_timed < time_type > :: monitor < input_t , output_t >:: options () . with_time_field_name ( \"timestamp\" ) . with_value_field_name ( \"verdict\" ); Here we used dense_timed<time_type> construct to denote we want a dense timed monitor. Unlike discrete time monitors, here we can use floating types, typically double . After we set out input-output types, we make our dense timed monitors in the same way: std :: string pattern = \"(historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning}\" ; auto my_monitor_1 = reelay :: make_monitor ( pattern , opts ); The execution also works similar way; however, now notice that the output is a json::array in particular. This is due to the verdict can change multiple times between two updates as we progress in time at arbitrary amounts in dense timed model. In other words, our monitors outputs all changes between the last time and current time point. And if nothing changes the outputs would be just empty. Below is an example execution for dense timed monitors. for ( std :: string line ; std :: getline ( input_file , line );) { reelay :: json message = reelay :: json :: parse ( line ); auto r1 = my_monitor_1 . update ( message ); if ( not r1 . empty ()){ for ( const auto & segment : r1 ) { std :: cout << segment << std :: endl ; } } } The complete source file of the dense timed monitor of DOW warning tutorial can be found here .","title":"Check Requirements over Dense Time Behaviors"},{"location":"gs_intro/","text":"Tutorial: Introduction This first part of the tutorial is about why we have system requirements and how to write them in the declative specification languages. We will use Reelay Expression Format to write our specifications. The following parts will about how to check these specifications over temporal data streams using Reelay monitors in C++ or Python . Throught the tutorial, we use an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature but it must be tested properly! An Example Feature So we want to design a feature that warns the user whenever our system (robot) detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another time. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into (testable) system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: For example, a discrete time behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... where our robot sample one data point per a fixed time unit. Alternatively, we could have designed an asynchronous (event-driven) architecture and emitted timestamped observations at irregular intervals , which we call dense time behaviors . Reelay uses the same specification to generate runtime monitors either for discrete or dense time behaviors. Next sections will be about writing these requirements in Reelay Expression format, an unambigious and executable specification language. Specify Requirements We will use Reelay Expression (RYE) format to specify our requirements. RYE format is a temporal logic based formal language, commonly used to describe temporal patterns over signals in a precise and unambigious manner. Reelay can compile RYE specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in RYE: (historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning} The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b]{cond} tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5]{door_open} is true if door_open is always true from 5 minutes ago to now . The reference for Reelay expression format is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. {door_open_warning} -> historically[0:5]{door_open} {door_open_warning} -> not{dow_suppressed} Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . {door_open_warning} -> not(pre({door_open} since {door_open_warning})) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5]{door_open} and not {dow_suppressed}) -> door_open_warning False Negative SYS-REQ-01 {door_open_warning} -> historically[0:5]{door_open} False Positive SYS-REQ-01 {door_open_warning} -> not{dow_suppressed} False Positive SYS-REQ-02 {door_open_warning} -> not(pre({door_open} since {door_open_warning})) False Positive Check Requirements Reelay has been designed for flexibility and efficiency in mind so that users can embed runtime specification monitoring for their projects in C++ or Python. Following tutorials will explain how to check these specifications over the system behavior. Check requirements in C++ Check requirements in Python","title":"Tutorial: Introduction"},{"location":"gs_intro/#tutorial-introduction","text":"This first part of the tutorial is about why we have system requirements and how to write them in the declative specification languages. We will use Reelay Expression Format to write our specifications. The following parts will about how to check these specifications over temporal data streams using Reelay monitors in C++ or Python . Throught the tutorial, we use an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature but it must be tested properly!","title":"Tutorial: Introduction"},{"location":"gs_intro/#an-example-feature","text":"So we want to design a feature that warns the user whenever our system (robot) detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another time. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into (testable) system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: For example, a discrete time behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... where our robot sample one data point per a fixed time unit. Alternatively, we could have designed an asynchronous (event-driven) architecture and emitted timestamped observations at irregular intervals , which we call dense time behaviors . Reelay uses the same specification to generate runtime monitors either for discrete or dense time behaviors. Next sections will be about writing these requirements in Reelay Expression format, an unambigious and executable specification language.","title":"An Example Feature"},{"location":"gs_intro/#specify-requirements","text":"We will use Reelay Expression (RYE) format to specify our requirements. RYE format is a temporal logic based formal language, commonly used to describe temporal patterns over signals in a precise and unambigious manner. Reelay can compile RYE specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in RYE: (historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning} The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b]{cond} tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5]{door_open} is true if door_open is always true from 5 minutes ago to now . The reference for Reelay expression format is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. {door_open_warning} -> historically[0:5]{door_open} {door_open_warning} -> not{dow_suppressed} Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . {door_open_warning} -> not(pre({door_open} since {door_open_warning})) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5]{door_open} and not {dow_suppressed}) -> door_open_warning False Negative SYS-REQ-01 {door_open_warning} -> historically[0:5]{door_open} False Positive SYS-REQ-01 {door_open_warning} -> not{dow_suppressed} False Positive SYS-REQ-02 {door_open_warning} -> not(pre({door_open} since {door_open_warning})) False Positive","title":"Specify Requirements"},{"location":"gs_intro/#check-requirements","text":"Reelay has been designed for flexibility and efficiency in mind so that users can embed runtime specification monitoring for their projects in C++ or Python. Following tutorials will explain how to check these specifications over the system behavior. Check requirements in C++ Check requirements in Python","title":"Check Requirements"},{"location":"gs_python/","text":"Getting Started From Python In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay Python Package The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay monitors that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these monitors with pre-defined datatypes and a thin layer of Pythonic user interface. We import Reelay monitors as follows: import reelay The package consists of two constructs discrete_time_monitor and dense_timed_monitor . Normally you would select discrete timed model if you work on discrete time behaviors and dense timed model if dense time behaviors. This choice depends on on your system and needs. If you haven't already, please check the documentation on discrete and dense time behaviors before proceeding. Check Requirements over Discrete Time Behaviors In this section we demonstrate how to configure, build and run a discrete timed Reelay monitor in Python. As typical in Python, we give monitor configuration options as keyword arguments as follows. my_monitor_1 = reelay . discrete_timed_monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} ) -> {door_open_warning} \" , condense = False ) Reelay Python monitor uses Python dicts/lists conveniently. Then we execute the monitor using update method, which accepts a single Python dictionary. for x in faulty_sys_behavior : r1 = my_monitor_1 . update ( x ) if r1 [ \"value\" ] is False : print ( 'Error at {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) where faulty_sys_behavior is a list of Python dicts. And the output r1 is similarly a Python dict that contains the result at that time step. Finally in this tutorial, since our requirements must be true for all time points, we print an error message if there is any violation. The complete source file of the discrete timed monitor of DOW warning tutorial can be found here . Check Requirements over Dense Time Behaviors In this section we demonstrate how to configure, build and run a dense timed Reelay monitor in Python. Similar to the discrete monitors, we create a dense timed monitor as folows: my_monitor_1 = reelay . dense_timed_monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} ) -> {door_open_warning} \" ) For dense timed monitors, remember that we yield a list of dicts at each update step. This is due to the verdict can change multiple times between two updates as we progress in time at arbitrary amounts in dense timed model. In other words, our monitors outputs all changes between the last time and current time point. And if nothing changes the outputs would be just empty. Below is an example execution for dense timed monitors. results = [] for x in faulty_sys_behavior : r1 = my_monitor_1 . update ( x ) results . extend ( r1 ) print ( results ) # Print all where faulty_sys_behavior is a list of dicts. And the output r1 is similarly a list of dicts that contains the result at that time step. The complete source file of the dense timed monitor of DOW warning tutorial can be found here .","title":"Use Reelay from Python"},{"location":"gs_python/#getting-started-from-python","text":"In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From Python"},{"location":"gs_python/#reelay-python-package","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay monitors that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these monitors with pre-defined datatypes and a thin layer of Pythonic user interface. We import Reelay monitors as follows: import reelay The package consists of two constructs discrete_time_monitor and dense_timed_monitor . Normally you would select discrete timed model if you work on discrete time behaviors and dense timed model if dense time behaviors. This choice depends on on your system and needs. If you haven't already, please check the documentation on discrete and dense time behaviors before proceeding.","title":"Reelay Python Package"},{"location":"gs_python/#check-requirements-over-discrete-time-behaviors","text":"In this section we demonstrate how to configure, build and run a discrete timed Reelay monitor in Python. As typical in Python, we give monitor configuration options as keyword arguments as follows. my_monitor_1 = reelay . discrete_timed_monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} ) -> {door_open_warning} \" , condense = False ) Reelay Python monitor uses Python dicts/lists conveniently. Then we execute the monitor using update method, which accepts a single Python dictionary. for x in faulty_sys_behavior : r1 = my_monitor_1 . update ( x ) if r1 [ \"value\" ] is False : print ( 'Error at {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) where faulty_sys_behavior is a list of Python dicts. And the output r1 is similarly a Python dict that contains the result at that time step. Finally in this tutorial, since our requirements must be true for all time points, we print an error message if there is any violation. The complete source file of the discrete timed monitor of DOW warning tutorial can be found here .","title":"Check Requirements over Discrete Time Behaviors"},{"location":"gs_python/#check-requirements-over-dense-time-behaviors","text":"In this section we demonstrate how to configure, build and run a dense timed Reelay monitor in Python. Similar to the discrete monitors, we create a dense timed monitor as folows: my_monitor_1 = reelay . dense_timed_monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} ) -> {door_open_warning} \" ) For dense timed monitors, remember that we yield a list of dicts at each update step. This is due to the verdict can change multiple times between two updates as we progress in time at arbitrary amounts in dense timed model. In other words, our monitors outputs all changes between the last time and current time point. And if nothing changes the outputs would be just empty. Below is an example execution for dense timed monitors. results = [] for x in faulty_sys_behavior : r1 = my_monitor_1 . update ( x ) results . extend ( r1 ) print ( results ) # Print all where faulty_sys_behavior is a list of dicts. And the output r1 is similarly a list of dicts that contains the result at that time step. The complete source file of the dense timed monitor of DOW warning tutorial can be found here .","title":"Check Requirements over Dense Time Behaviors"},{"location":"install/","text":"Install Dependencies 1) C++11 Compiler (for C++ or Python users) Reelay requires a C++ compiler compliant with C++11 standard. Today all major compiler frameworks already provide full C++11 support. We mainly use gcc and sometimes clang for additional analyses (e.g. extra warnings). 2) Boost C++ Libraries (for C++ or Python users) Reelay requires Boost C++ libraries at several places. In particular, we heavily use Boost Interval Container Library (ICL) inside timed monitors. Below is a list of how to install Boost for several environments: For Debian/Ubuntu: apt install -y libboost-all-dev For CentOS/Fedora: yum install -y boost-devel For Arch/Manjaro: pacman -S boost For MacOS (assuming homebrew installed): brew install boost Note that we mainly develop Reelay on Ubuntu 20.04 therefore it's the most tested environment among these environments. For Windows machines, we suggest installing Reelay on Ubuntu on Windows Subsystem for Linux (WSL). 3) CUDD Library (only for C++ users) Reelay data monitors additionally require CUDD binary decision diagram (BDD) library. If CUDD library is not installed on your system, please see the next section how to build CUDD from the source. 4) Pybind11 (only for Python users) To use Reelay in Python, we additionaly require the package pybind11 that provides seamless operability between C++11 and Python. python -m pip install pybind11 This command also install pybind11 package and required C++ header files such as pybind11/pybind11.h and pybind11/stl.h . Install Reelay C++ Library This section describe the installation steps on Ubuntu 18.04. First, clone the reelay repository and its submodules using --recursive flag as follows: git clone https://github.com/doganulus/reelay.git --recurse-submodules cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Finally you can build and install CUDD library by typing: make cudd sudo make cudd-install These commands will build the shared library libcudd.so and place it under /usr/local/lib directory by default. Programs that use Reelay data monitors have to link this library at the compilation. Install Reelay Python Package A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: python -m pip install reelay The command above will install latest release of Reelay. Here python executable could be any python3 executable as Reelay is tested from 3.5 to the latest 3.8 . Alternatively you can install the development version of Reelay from the master branch directly. python -m pip install git+https://github.com/doganulus/reelay.git This command will build the extension module from the source therefore it may take longer to install. Finally Python installation handles the CUDD dependency automatically and you do not need to install CUDD if you are only interested in using Reelay from Python.","title":"From Source"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#dependencies","text":"","title":"Dependencies"},{"location":"install/#1-c11-compiler-for-c-or-python-users","text":"Reelay requires a C++ compiler compliant with C++11 standard. Today all major compiler frameworks already provide full C++11 support. We mainly use gcc and sometimes clang for additional analyses (e.g. extra warnings).","title":"1) C++11 Compiler (for C++ or Python users)"},{"location":"install/#2-boost-c-libraries-for-c-or-python-users","text":"Reelay requires Boost C++ libraries at several places. In particular, we heavily use Boost Interval Container Library (ICL) inside timed monitors. Below is a list of how to install Boost for several environments: For Debian/Ubuntu: apt install -y libboost-all-dev For CentOS/Fedora: yum install -y boost-devel For Arch/Manjaro: pacman -S boost For MacOS (assuming homebrew installed): brew install boost Note that we mainly develop Reelay on Ubuntu 20.04 therefore it's the most tested environment among these environments. For Windows machines, we suggest installing Reelay on Ubuntu on Windows Subsystem for Linux (WSL).","title":"2) Boost C++ Libraries (for C++ or Python users)"},{"location":"install/#3-cudd-library-only-for-c-users","text":"Reelay data monitors additionally require CUDD binary decision diagram (BDD) library. If CUDD library is not installed on your system, please see the next section how to build CUDD from the source.","title":"3) CUDD Library (only for C++ users)"},{"location":"install/#4-pybind11-only-for-python-users","text":"To use Reelay in Python, we additionaly require the package pybind11 that provides seamless operability between C++11 and Python. python -m pip install pybind11 This command also install pybind11 package and required C++ header files such as pybind11/pybind11.h and pybind11/stl.h .","title":"4) Pybind11 (only for Python users)"},{"location":"install/#install-reelay-c-library","text":"This section describe the installation steps on Ubuntu 18.04. First, clone the reelay repository and its submodules using --recursive flag as follows: git clone https://github.com/doganulus/reelay.git --recurse-submodules cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Finally you can build and install CUDD library by typing: make cudd sudo make cudd-install These commands will build the shared library libcudd.so and place it under /usr/local/lib directory by default. Programs that use Reelay data monitors have to link this library at the compilation.","title":"Install Reelay C++ Library"},{"location":"install/#install-reelay-python-package","text":"A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: python -m pip install reelay The command above will install latest release of Reelay. Here python executable could be any python3 executable as Reelay is tested from 3.5 to the latest 3.8 . Alternatively you can install the development version of Reelay from the master branch directly. python -m pip install git+https://github.com/doganulus/reelay.git This command will build the extension module from the source therefore it may take longer to install. Finally Python installation handles the CUDD dependency automatically and you do not need to install CUDD if you are only interested in using Reelay from Python.","title":"Install Reelay Python Package"},{"location":"license/","text":"The Reelay project is licensed under the MPL 2.0 . The MPL 2.0 is a simple copyleft license. The MPL's \"file-level\" copyleft is designed to encourage contributors to share modifications they make to your code, while still allowing them to combine your code with code under other licenses (open or proprietary) with minimal restrictions. Please also check frequently asked questions and answers about using and distributing code under the MPL 2.0 from here .","title":"License"},{"location":"literature/","text":"Academic Literature Here is the list of eleven papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Efficient robust monitoring for STL by Alexandre Donze, Thomas Ferrere, and Oded Maler. 2013. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"References"},{"location":"literature/#academic-literature","text":"Here is the list of eleven papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Efficient robust monitoring for STL by Alexandre Donze, Thomas Ferrere, and Oded Maler. 2013. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Academic Literature"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmarking"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"rye/","text":"Reelay Expression Format Reelay reads executable specifications written in plain text and verifies that the system does what those specifications say at runtime. To construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Rye format for short. What is Rye Format? Rye format uses a set of special constructs (that is, keywords and punctuation) to describe desired system behavior over temporal data streams expressed in structured data formats like multiline JSON or CSV. These syntactic constructs are divided into four categories: Atomic expressions Boolean logic expressions Temporal logic expressions Regular expressions (in future releases) Let's start with atomic expressions. Atomic Expressions Atomic expressions are the basic building blocks of Reelay expressions. Basic atoms use the curly-bracket syntax {...} and describes a set of constraints over data objects. For example, an atomic expression such as {lights_on: true, speed > 20.0, mode: \"Sport XL\"} will be evaluated to true for time points 101 and 102 below over a temporal behavior given as a sequence of JSON objects such that ... { \"time\" : 101 , \"lights_on\" : true , \"speed\" : 21.23 , \"mode\" : \"Sport XL\" } { \"time\" : 102 , \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Sport XL\" } { \"time\" : 103 , \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Sport XL\" } ... Currently Reelay supports Booleans ( true , false ), numerical comparisons ( < , <= , > , >= , == , != ), string equivalences inside curly atoms over data objects. Non-existent or unspecified field names in data objects and their values do not change the value of the atomic expression. For example, an atomic expression such as {speed > 21.0} will be evaluated to true for the time point 101 and false for time points 102 and 103 regardless of the value of other fields in the objects. For the case where you require that a field exists in the object but don't care about its value, Reelay uses the asterisk ( * ) symbol to denote that any value is acceptable. For example, {lights_on: true, speed > 19.0, mode: *} will be evaluated to true for time points 101 , 102 , and 103 but to false for a data object { \"time\" : 104 , \"lights_on\" : true , \"speed\" : 21.23 } since it does not contain any field named as mode .","title":"Rye Format"},{"location":"rye/#reelay-expression-format","text":"Reelay reads executable specifications written in plain text and verifies that the system does what those specifications say at runtime. To construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Rye format for short.","title":"Reelay Expression Format"},{"location":"rye/#what-is-rye-format","text":"Rye format uses a set of special constructs (that is, keywords and punctuation) to describe desired system behavior over temporal data streams expressed in structured data formats like multiline JSON or CSV. These syntactic constructs are divided into four categories: Atomic expressions Boolean logic expressions Temporal logic expressions Regular expressions (in future releases) Let's start with atomic expressions.","title":"What is Rye Format?"},{"location":"rye/#atomic-expressions","text":"Atomic expressions are the basic building blocks of Reelay expressions. Basic atoms use the curly-bracket syntax {...} and describes a set of constraints over data objects. For example, an atomic expression such as {lights_on: true, speed > 20.0, mode: \"Sport XL\"} will be evaluated to true for time points 101 and 102 below over a temporal behavior given as a sequence of JSON objects such that ... { \"time\" : 101 , \"lights_on\" : true , \"speed\" : 21.23 , \"mode\" : \"Sport XL\" } { \"time\" : 102 , \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Sport XL\" } { \"time\" : 103 , \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Sport XL\" } ... Currently Reelay supports Booleans ( true , false ), numerical comparisons ( < , <= , > , >= , == , != ), string equivalences inside curly atoms over data objects. Non-existent or unspecified field names in data objects and their values do not change the value of the atomic expression. For example, an atomic expression such as {speed > 21.0} will be evaluated to true for the time point 101 and false for time points 102 and 103 regardless of the value of other fields in the objects. For the case where you require that a field exists in the object but don't care about its value, Reelay uses the asterisk ( * ) symbol to denote that any value is acceptable. For example, {lights_on: true, speed > 19.0, mode: *} will be evaluated to true for time points 101 , 102 , and 103 but to false for a data object { \"time\" : 104 , \"lights_on\" : true , \"speed\" : 21.23 } since it does not contain any field named as mode . <!-- Quite often we have to deal with complex hierarchial data objects such as <div class=\"codehilite\"> ... { \"time\" : 104 , \"ego\" : { \"lights_on\" : true , \"motion\" : { \"position\" : [ 117.2 , -345.7 ], \"speed\" : 21.23 } } } .. when monitoring real-time systems. Therefore, Reelay support hierarchical atoms and uses `::` operator to specify the path of hierarchy as follows: ego::motion::{speed > 21.0} These path will be calculated from the current namespace, and initially from the root of the main data object. Reelay also provides a limited support for array-like structures and currently allows the specification of indices using `$index` syntax such that ego::motion::position::{$0 > 100.0, $1 > 0.0} ``` --> <!-- As usual we can use zero-based indexing in our specifications. --> Finally Reelay allows to declare categorical variable references inside atoms using the `*ref_name` syntax such that ```rye {lights_on: true, speed > 20, mode: *myref} Then this reference called `myref` can be used elsewhere in the expression and quantified by `exists` and `forall` operators. More details regarding these operators are given in the following section of logical constructs. #### Boolean Logic Expressions This section describe Boolean logic operations over atomic Reelay expressions. we mainly use curly atoms in the examples but these constructs are equally applicable unless anything noted. ##### Negation The negation of Reelay expressions is defined by using keywords `not` and `!`. not {key1: value1, key2: value2} ##### Conjunction The conjuction of Reelay expressions is defined by using keywords `and` and `&&`. One can see that atomic expression syntax is a shortcut for conjunction between atomic constraints. Two Reelay expressions below are functionally equivalent: {key1: value1, key2: value2} and {key1: value1} and {key2: value2} ##### Disjunction The disjunction of constraints has to defined explicitly using keywords `or` and `||`. {key1: value1} or {key2: value2} ##### Logical Implication Logical implication is a popular Boolean operation when writing conditional specifications. The logical implication of constraints has to defined explicitly using keywords `implies` and `->`. {key1: value1} -> {key2: value2} ##### References and Quantifiers The ability to refer to data values (unknown at compile time) is one of the advanced features of Reelay. Roughly speaking, a reference variable acts a memory location where many data values (from a key) can be stored and can be checked later (or with another key) for the equality. Then these data values can quantified for existence (`exists`) and universality (`forall`). Note that this feature is currently supported for categorical variables (e.g. strings) only. The syntax for references and quantifiers is as follows: exists[ref1, ref2, ...]. RYE(ref1, ref2, ...) forall[ref1, ref2, ...]. RYE(ref1, ref2, ...) where `RYE(ref1, ref2, ...)` is an arbitrary Reelay expression that contains reference declarations `ref1, ref2, ...` inside its atoms. For example, we may want to check the equality of data values for two fields but don't know or cannot write all possible cases at compile time. exists[refname]. {key1: *refname, key2: *refname} This expression above will be evaluated to `true` for the data object { \"key1\" : \"hello\" , \"key2\" : \"hello\" } but `false` for the data object { \"key1\" : \"hello\" , \"key2\" : \"world\" } as two string values are not equal in the latter. More advanced use of references involve temporal expressions explained in the following sections, which allow us checking data values from different time points. #### Temporal Logic Expressions ##### Previously The unary operation of `previously` is defined using keywords `pre` and `Y`. For example, consider the Reelay expression pre{lights_on: true} which is true at the current time point if lights were on in the previous time point. Note that `previously` operation is only meaningful for untimed and discrete timed settings but dense timed settings. ##### Sometime in the Past, Once The unary operation of `once` is defined using keywords `once` and `P`. For example, consider the Reelay expression once{lights_on: true} which is true at the current time point if lights were on in sometime in the past. It is possible to add timing constraints to the specification such that once[a:b]{lights_on: true} which is true at the current time point if lights were always on in sometime between `b` and `a` time units before now. We use the syntax `[a:]` and `[:b]` if there is no constraints on upper and lower bounds, respectively. ##### Always in the Past, Historically The unary operation of `historically` is defined using keywords `historically` and `H`. For example, consider the Reelay expression historically{lights_on: true} which is true at the current time point if lights were on in some time in the past. It is possible to add timing constraints to the specification such that historically[a:b]{lights_on: true} which is true at the current time point if lights were always on between `b` and `a` time units before now. We use the syntax `[a:]` and `[:b]` if there is no constraints on upper and lower bounds, respectively. ##### Since The binary operation of `since` is defined using keywords `since` and `S`. For example, consider the Reelay expression {speed < 30} since {lights_on: true} which is true at the current time point if the variable `speed` is always less than 30 units since `lights_on` is true last time. It is possible to add timing constraints to the specification such that {speed < 30} since[a:b] {lights_on: true} which is true at the current time point if the variable `speed` is always less than 30 since `lights_on` is true sometime between `b` and `a` time units before now. We use the syntax `[a:]` and `[:b]` if there is no constraints on upper and lower bounds, respectively. #### A Note regarding Operator Precedence As a rule of thumb, unary operators bind stronger than binary operators (except quantifiers, better use parantheses) and unary operators are eagerly matching therefore an expression such as not {...} since {...} would be parsed as (not {...}) since {...} and not as not ({...} since {...})","title":"Atomic Expressions"}]}