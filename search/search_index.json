{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reelay Monitors Reelay is a header-only C++ library for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase. Features Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line Rye Format Reelay reads executable specifications written in plain text and verifies at runtime that the system does what those specifications describe. In order to construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Reelay Expression (Rye) format. See Rye format reference for more details. Get Started The next steps for you are to install Reelay from source code , pip , or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ and Python . Contribute Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment.","title":"Home"},{"location":"#reelay-monitors","text":"Reelay is a header-only C++ library for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase.","title":"Reelay Monitors"},{"location":"#features","text":"Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line","title":"Features"},{"location":"#rye-format","text":"Reelay reads executable specifications written in plain text and verifies at runtime that the system does what those specifications describe. In order to construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Reelay Expression (Rye) format. See Rye format reference for more details.","title":"Rye Format"},{"location":"#get-started","text":"The next steps for you are to install Reelay from source code , pip , or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ and Python .","title":"Get Started"},{"location":"#contribute","text":"Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment.","title":"Contribute"},{"location":"author/","text":"Dogan Ulus Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Author"},{"location":"author/#dogan-ulus","text":"Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Dogan Ulus"},{"location":"behaviors/","text":"Temporal Behaviors A temporal behavior of a system is a time-ordered sequence of observations regarging the system. There are two primary models of temporal behaviors we consider in Reelay: Discrete time behaviors Dense time behaviors where the main distinction for the user is how time progresses between two observations. For discrete time behaviors, time value increases exactly 1 time unit between two observations. For dense time behaviors, however, time can increase at arbitrary amounts including fractional values. In that case, an explicit timing information such as a timestamp is added to the observation data. In the following we use multiline JSON files to represent temporal behaviors to give examples and explain some important concepts. Discrete Time Behaviors and Persistence The multiline JSON document below represents a discrete time behavior where each JSON object containing three variables regarding a system. For discrete time behaviors the progression of time is implicit as time value increases one by one for each line starting from zero. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Start\" } // time: 1 { \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Start\" } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 4 ... Normally each temporal variable of the system is recorded in such JSON objects (or other equivalent representation) for each time point. Usually temporal variables do not change their value for every time point. Indeed they can have the same value for long time periods. The concept of persistence c Persistence means that we interpret the value of temporal variables from the last time when they are set in the behavior. In other words, once a temporal variable set in the behavior, its value persists until it is set again. For example, the previous discrete time behavior can be equivalently represented under persistance interpreation as below. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 } // time: 1 { \"speed\" : 19.12 } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 {} // time: 4 In Reelay we support persistent discrete time behaviors and it is encouraged to use persistent behaviors for efficiency reasons. Finally notice that discrete time behaviors would contain sequences of empty JSON objects if no value changed from previous time points (again a common case in real life systems). Monitors will be updated at each time point for the same values for a long time period, which is not very efficient. Here it is better to switch dense time model as we need to process many time points having the same value at once. Dense Time Behaviors Dense time behaviors contain extra timing information next to the observation data. In Reelay we reserve top-level time keyword for this purpose. This allows to represent temporal behaviors changing at irregular intervals and jump many time points at once. Dense time behaviors are also persistent meaning that temporal variables retain their values for skipped times. For example, suppose we have a dense time behavior as below: { \"time\" : 0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32 , \"speed\" : 19.12 } { \"time\" : 65 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100 } When a dense timed Reelay monitor processes this temporal behavior, it call its update method 5 times (1 for each line) whereas a discrete timed monitor would need 100 calls. An update step of dense timed monitors is more expensive than that of discrete timed monitors but there is a point using dense time model becomes advantegous. Therefore, we provide both discrete and dense timed monitors in Reelay where the former is better suited for fast and regularly updated systems and the latter for slow and irregularly ones. Finally, since we no longer need to progress one-by-one, we can also progress smaller steps or fractional steps. Below is a dense time behavior using floating point numbers for time field. { \"time\" : 0.0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11.3 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32.1 , \"speed\" : 19.12 } { \"time\" : 65.13 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100.0 } And the user can select the base time type (currently only primitive types) for Reelay monitors depending on their system. Final remark This document aimed to give a practical view of temporal behaviors for the user rather than precise mathematical definitions of discrete and dense time behaviors.","title":"Temporal Behaviors"},{"location":"behaviors/#temporal-behaviors","text":"A temporal behavior of a system is a time-ordered sequence of observations regarging the system. There are two primary models of temporal behaviors we consider in Reelay: Discrete time behaviors Dense time behaviors where the main distinction for the user is how time progresses between two observations. For discrete time behaviors, time value increases exactly 1 time unit between two observations. For dense time behaviors, however, time can increase at arbitrary amounts including fractional values. In that case, an explicit timing information such as a timestamp is added to the observation data. In the following we use multiline JSON files to represent temporal behaviors to give examples and explain some important concepts.","title":"Temporal Behaviors"},{"location":"behaviors/#discrete-time-behaviors-and-persistence","text":"The multiline JSON document below represents a discrete time behavior where each JSON object containing three variables regarding a system. For discrete time behaviors the progression of time is implicit as time value increases one by one for each line starting from zero. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Start\" } // time: 1 { \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Start\" } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 4 ... Normally each temporal variable of the system is recorded in such JSON objects (or other equivalent representation) for each time point. Usually temporal variables do not change their value for every time point. Indeed they can have the same value for long time periods. The concept of persistence c Persistence means that we interpret the value of temporal variables from the last time when they are set in the behavior. In other words, once a temporal variable set in the behavior, its value persists until it is set again. For example, the previous discrete time behavior can be equivalently represented under persistance interpreation as below. { \"lights_on\" : false , \"speed\" : 21.23 , \"mode\" : \"Start\" } // time: 0 { \"lights_on\" : true , \"speed\" : 20.01 } // time: 1 { \"speed\" : 19.12 } // time: 2 { \"lights_on\" : false , \"speed\" : 19.18 , \"mode\" : \"Sport\" } // time: 3 {} // time: 4 In Reelay we support persistent discrete time behaviors and it is encouraged to use persistent behaviors for efficiency reasons. Finally notice that discrete time behaviors would contain sequences of empty JSON objects if no value changed from previous time points (again a common case in real life systems). Monitors will be updated at each time point for the same values for a long time period, which is not very efficient. Here it is better to switch dense time model as we need to process many time points having the same value at once.","title":"Discrete Time Behaviors and Persistence"},{"location":"behaviors/#dense-time-behaviors","text":"Dense time behaviors contain extra timing information next to the observation data. In Reelay we reserve top-level time keyword for this purpose. This allows to represent temporal behaviors changing at irregular intervals and jump many time points at once. Dense time behaviors are also persistent meaning that temporal variables retain their values for skipped times. For example, suppose we have a dense time behavior as below: { \"time\" : 0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32 , \"speed\" : 19.12 } { \"time\" : 65 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100 } When a dense timed Reelay monitor processes this temporal behavior, it call its update method 5 times (1 for each line) whereas a discrete timed monitor would need 100 calls. An update step of dense timed monitors is more expensive than that of discrete timed monitors but there is a point using dense time model becomes advantegous. Therefore, we provide both discrete and dense timed monitors in Reelay where the former is better suited for fast and regularly updated systems and the latter for slow and irregularly ones. Finally, since we no longer need to progress one-by-one, we can also progress smaller steps or fractional steps. Below is a dense time behavior using floating point numbers for time field. { \"time\" : 0.0 , \"lights_on\" : false , \"speed\" : 21.23 } { \"time\" : 11.3 , \"lights_on\" : true , \"speed\" : 20.01 } { \"time\" : 32.1 , \"speed\" : 19.12 } { \"time\" : 65.13 , \"lights_on\" : false , \"speed\" : 19.18 } { \"time\" : 100.0 } And the user can select the base time type (currently only primitive types) for Reelay monitors depending on their system.","title":"Dense Time Behaviors"},{"location":"behaviors/#final-remark","text":"This document aimed to give a practical view of temporal behaviors for the user rather than precise mathematical definitions of discrete and dense time behaviors.","title":"Final remark"},{"location":"cpp_api/","text":"(Under construction)","title":"C++ API"},{"location":"docker/","text":"Running Reelay in a Docker container This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl '{p1} since[18:24] {p2}' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Docker Image"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl '{p1} since[18:24] {p2}' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Running Reelay in a Docker container"},{"location":"gs_cli/","text":"Getting Started From Terminal (Under construction)","title":"Getting Started From Terminal"},{"location":"gs_cli/#getting-started-from-terminal","text":"(Under construction)","title":"Getting Started From Terminal"},{"location":"gs_cpp/","text":"Getting Started From C++ In this part, we show how to instatiate and execute Reelay monitors in C++ given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay C++ Library and Recipes The core component of Reelay is a header-only template library for C++ supporting several specification languages. Templates allow to customize monitors for different input types (e.g std::tuple or std::map ) or different time types (e.g. int64_t or double ). In this tutorial, we will use Reelay recipes, a predefined selection of concrete monitor classes that instatiates monitor templates by convenient datatypes. We include Reelay recipes into our source file as follows: #include \"reelay/recipes.hpp\" Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name input_t time_t Gaps in behaviors reelay::past_ltl_monitor std::map<std::string, bool> - No reelay::past_mtl_monitor std::map<std::string, int64_t> int64_t Yes reelay::discrete_timed_past_mtl_monitor std::map<std::string, int64_t> int64_t No reelay::past_stl_monitor std::map<std::string, double> double Yes reelay::discrete_timed_past_stl_monitor std::map<std::string, double> int64_t No Please also check the User Manual for the information regarding reelay/recipes.hpp as well as reelay/monitors.hpp , which provide a nice interface for full datatype customization of monitors. We provide further information on time models and temporal logics under advanced topics. Check Requirements over System Behaviors Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. using input_t = std :: map < std :: string , int64_t > ; std :: vector < input_t > correct_sys_behavior = std :: vector < input_t > (); correct_sys_behavior . push_back ( input_t {{ \"time\" , 1 }, { \"door_open\" , 0 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 2 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 3 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 4 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 5 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 6 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 7 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 1 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 8 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 9 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: auto my_monitor_1 = reelay :: discrete_timed_past_mtl_monitor ( \"(historically[0:5]{door_open} and not{dow_suppressed}) -> { door_open_warning } \"); The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for ( const auto & message : correct_sys_behavior ) { auto check_1 = my_monitor_1 . update ( message ); if ( not check_1 ) { std :: cout << \"Error at time \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all. Inserting an Error (Under construction) Time Gaps in Behaviors (Under construction)","title":"Use Reelay from C++"},{"location":"gs_cpp/#getting-started-from-c","text":"In this part, we show how to instatiate and execute Reelay monitors in C++ given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From C++"},{"location":"gs_cpp/#reelay-c-library-and-recipes","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. Templates allow to customize monitors for different input types (e.g std::tuple or std::map ) or different time types (e.g. int64_t or double ). In this tutorial, we will use Reelay recipes, a predefined selection of concrete monitor classes that instatiates monitor templates by convenient datatypes. We include Reelay recipes into our source file as follows: #include \"reelay/recipes.hpp\" Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name input_t time_t Gaps in behaviors reelay::past_ltl_monitor std::map<std::string, bool> - No reelay::past_mtl_monitor std::map<std::string, int64_t> int64_t Yes reelay::discrete_timed_past_mtl_monitor std::map<std::string, int64_t> int64_t No reelay::past_stl_monitor std::map<std::string, double> double Yes reelay::discrete_timed_past_stl_monitor std::map<std::string, double> int64_t No Please also check the User Manual for the information regarding reelay/recipes.hpp as well as reelay/monitors.hpp , which provide a nice interface for full datatype customization of monitors. We provide further information on time models and temporal logics under advanced topics.","title":"Reelay C++ Library and Recipes"},{"location":"gs_cpp/#check-requirements-over-system-behaviors","text":"Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. using input_t = std :: map < std :: string , int64_t > ; std :: vector < input_t > correct_sys_behavior = std :: vector < input_t > (); correct_sys_behavior . push_back ( input_t {{ \"time\" , 1 }, { \"door_open\" , 0 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 2 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 3 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 4 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 5 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 6 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 7 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 1 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 8 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 9 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: auto my_monitor_1 = reelay :: discrete_timed_past_mtl_monitor ( \"(historically[0:5]{door_open} and not{dow_suppressed}) -> { door_open_warning } \"); The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for ( const auto & message : correct_sys_behavior ) { auto check_1 = my_monitor_1 . update ( message ); if ( not check_1 ) { std :: cout << \"Error at time \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all.","title":"Check Requirements over System Behaviors"},{"location":"gs_cpp/#inserting-an-error","text":"(Under construction)","title":"Inserting an Error"},{"location":"gs_cpp/#time-gaps-in-behaviors","text":"(Under construction)","title":"Time Gaps in Behaviors"},{"location":"gs_intro/","text":"Tutorial: Introduction This first part of the tutorial is about why we have system requirements and how to write them in the declative specification languages. We will use Reelay Expression Format to write our specifications. The following parts will about how to check these specifications over temporal data streams using Reelay monitors in C++ or Python . Throught the tutorial, we use an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature but it must be tested properly! An Example Feature So we want to design a feature that warns the user whenever our system (robot) detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another time. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into (testable) system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: For example, a discrete time behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... where our robot sample one data point per a fixed time unit. Alternatively, we could have designed an asynchronous (event-driven) architecture and emitted timestamped observations at irregular intervals , which we call dense time behaviors . Reelay uses the same specification to generate runtime monitors either for discrete or dense time behaviors. Next sections will be about writing these requirements in Reelay Expression format, an unambigious and executable specification language. Specify Requirements We will use Reelay Expression (RYE) format to specify our requirements. RYE format is a temporal logic based formal language, commonly used to describe temporal patterns over signals in a precise and unambigious manner. Reelay can compile RYE specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in RYE: (historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning} The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b]{cond} tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5]{door_open} is true if door_open is always true from 5 minutes ago to now . The reference for Reelay expression format is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. {door_open_warning} -> historically[0:5]{door_open} {door_open_warning} -> not{dow_suppressed} Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . {door_open_warning} -> not(pre({door_open} since {door_open_warning})) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5]{door_open} and not {dow_suppressed}) -> door_open_warning False Negative SYS-REQ-01 {door_open_warning} -> historically[0:5]{door_open} False Positive SYS-REQ-01 {door_open_warning} -> not{dow_suppressed} False Positive SYS-REQ-02 {door_open_warning} -> not(pre({door_open} since {door_open_warning})) False Positive Check Requirements Reelay has been designed for flexibility and efficiency in mind so that users can embed runtime specification monitoring for their projects in C++ or Python. Following tutorials will explain how to check these specifications over the system behavior. Check requirements in C++ Check requirements in Python","title":"Tutorial: Introduction"},{"location":"gs_intro/#tutorial-introduction","text":"This first part of the tutorial is about why we have system requirements and how to write them in the declative specification languages. We will use Reelay Expression Format to write our specifications. The following parts will about how to check these specifications over temporal data streams using Reelay monitors in C++ or Python . Throught the tutorial, we use an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature but it must be tested properly!","title":"Tutorial: Introduction"},{"location":"gs_intro/#an-example-feature","text":"So we want to design a feature that warns the user whenever our system (robot) detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another time. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into (testable) system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: For example, a discrete time behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... where our robot sample one data point per a fixed time unit. Alternatively, we could have designed an asynchronous (event-driven) architecture and emitted timestamped observations at irregular intervals , which we call dense time behaviors . Reelay uses the same specification to generate runtime monitors either for discrete or dense time behaviors. Next sections will be about writing these requirements in Reelay Expression format, an unambigious and executable specification language.","title":"An Example Feature"},{"location":"gs_intro/#specify-requirements","text":"We will use Reelay Expression (RYE) format to specify our requirements. RYE format is a temporal logic based formal language, commonly used to describe temporal patterns over signals in a precise and unambigious manner. Reelay can compile RYE specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in RYE: (historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning} The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b]{cond} tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5]{door_open} is true if door_open is always true from 5 minutes ago to now . The reference for Reelay expression format is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. {door_open_warning} -> historically[0:5]{door_open} {door_open_warning} -> not{dow_suppressed} Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . {door_open_warning} -> not(pre({door_open} since {door_open_warning})) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5]{door_open} and not {dow_suppressed}) -> door_open_warning False Negative SYS-REQ-01 {door_open_warning} -> historically[0:5]{door_open} False Positive SYS-REQ-01 {door_open_warning} -> not{dow_suppressed} False Positive SYS-REQ-02 {door_open_warning} -> not(pre({door_open} since {door_open_warning})) False Positive","title":"Specify Requirements"},{"location":"gs_intro/#check-requirements","text":"Reelay has been designed for flexibility and efficiency in mind so that users can embed runtime specification monitoring for their projects in C++ or Python. Following tutorials will explain how to check these specifications over the system behavior. Check requirements in C++ Check requirements in Python","title":"Check Requirements"},{"location":"gs_python/","text":"Getting Started From Python Warning Reelay Python API is in its early stage. Everthing in this page is subject to change. In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay Python Package The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay recipes that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these recipes together with a thin layer of Pythonic user interface. In this tutorial, we will use Reelay Python package imported into your project as follows: import reelay Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name Expected input type Default Time Model reelay.past_ltl.monitor dict[str, bool] N/A reelay.past_mtl.monitor dict[str, int] discrete reelay.past_stl.monitor dict[str, float] dense Please also check the User Manual for the information regarding Python API. We provide further information on time models and temporal logics under advanced topics. Check Requirements over System Behaviors Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. correct_sys_behavior = [ dict ( time = 1 , door_open = False , dow_suppressed = False , door_open_warning = False ), dict ( time = 2 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 3 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 4 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 5 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 6 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 7 , door_open = True , dow_suppressed = False , door_open_warning = True ), dict ( time = 8 , door_open = True , dow_suppressed = True , door_open_warning = False ), dict ( time = 9 , door_open = True , dow_suppressed = True , door_open_warning = False ), ] The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: my_monitor_1 = reelay . past_mtl . monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} -> \" \"door_open_warning\" , time_model = \"discrete\" ) The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for message in correct_sys_behavior : check_1 = my_monitor_1 . update ( message ) if not check_1 : print ( 'Error at time {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all. Inserting an Error (Under construction) Time Gaps in Behaviors (Under construction)","title":"Use Reelay from Python"},{"location":"gs_python/#getting-started-from-python","text":"Warning Reelay Python API is in its early stage. Everthing in this page is subject to change. In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From Python"},{"location":"gs_python/#reelay-python-package","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay recipes that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these recipes together with a thin layer of Pythonic user interface. In this tutorial, we will use Reelay Python package imported into your project as follows: import reelay Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name Expected input type Default Time Model reelay.past_ltl.monitor dict[str, bool] N/A reelay.past_mtl.monitor dict[str, int] discrete reelay.past_stl.monitor dict[str, float] dense Please also check the User Manual for the information regarding Python API. We provide further information on time models and temporal logics under advanced topics.","title":"Reelay Python Package"},{"location":"gs_python/#check-requirements-over-system-behaviors","text":"Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. correct_sys_behavior = [ dict ( time = 1 , door_open = False , dow_suppressed = False , door_open_warning = False ), dict ( time = 2 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 3 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 4 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 5 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 6 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 7 , door_open = True , dow_suppressed = False , door_open_warning = True ), dict ( time = 8 , door_open = True , dow_suppressed = True , door_open_warning = False ), dict ( time = 9 , door_open = True , dow_suppressed = True , door_open_warning = False ), ] The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: my_monitor_1 = reelay . past_mtl . monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} -> \" \"door_open_warning\" , time_model = \"discrete\" ) The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for message in correct_sys_behavior : check_1 = my_monitor_1 . update ( message ) if not check_1 : print ( 'Error at time {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all.","title":"Check Requirements over System Behaviors"},{"location":"gs_python/#inserting-an-error","text":"(Under construction)","title":"Inserting an Error"},{"location":"gs_python/#time-gaps-in-behaviors","text":"(Under construction)","title":"Time Gaps in Behaviors"},{"location":"install/","text":"Install Dependencies 1) C++11 Compiler (for C++ or Python users) Reelay requires a C++ compiler compliant with C++11 standard. Today all major compiler frameworks already provide full C++11 support. We mainly use gcc and sometimes clang for additional analyses (e.g. extra warnings). 2) Boost C++ Libraries (for C++ or Python users) Reelay requires Boost C++ libraries at several places. In particular, we heavily use Boost Interval Container Library (ICL) inside timed monitors. Below is a list of how to install Boost for several environments: For Debian/Ubuntu: apt install -y libboost-all-dev For CentOS/Fedora: yum install -y boost-devel For Arch/Manjaro: pacman -S boost For MacOS (assuming homebrew installed): brew install boost Note that we mainly develop Reelay on Ubuntu 18.04 therefore it's the most tested environment among these environments. For Windows machines, we suggest installing Reelay on Ubuntu 18.04 on Windows Subsystem for Linux (WSL). 3) CUDD Library (only for C++ users) Reelay data monitors additionally require CUDD binary decision diagram (BDD) library. If CUDD library is not installed on your system, please see the next section how to build CUDD from the source. 4) Pybind11 (only for Python users) To use Reelay in Python, we additionaly require the package pybind11 that provides seamless operability between C++11 and Python. python -m pip install pybind11 This command also install pybind11 package and required C++ header files such as pybind11/pybind11.h and pybind11/stl.h . Install Reelay C++ Library This section describe the installation steps on Ubuntu 18.04. First, clone the reelay repository and its submodules using --recursive flag as follows: git clone https://github.com/doganulus/reelay.git --recurse-submodules cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Finally you can build and install CUDD library by typing: make cudd sudo make cudd-install These commands will build the shared library libcudd.so and place it under /usr/local/lib directory by default. Programs that use Reelay data monitors have to link this library at the compilation. Install Reelay Python Package A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: python -m pip install reelay The command above will install latest release of Reelay. Here python executable could be any python3 executable as Reelay is tested from 3.5 to the latest 3.8 . Alternatively you can install the development version of Reelay from the master branch directly. python -m pip install git+https://github.com/doganulus/reelay.git This command will build the extension module from the source therefore it may take longer to install. Finally Python installation handles the CUDD dependency automatically and you do not need to install CUDD if you are only interested in using Reelay from Python.","title":"From Source"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#dependencies","text":"","title":"Dependencies"},{"location":"install/#1-c11-compiler-for-c-or-python-users","text":"Reelay requires a C++ compiler compliant with C++11 standard. Today all major compiler frameworks already provide full C++11 support. We mainly use gcc and sometimes clang for additional analyses (e.g. extra warnings).","title":"1) C++11 Compiler (for C++ or Python users)"},{"location":"install/#2-boost-c-libraries-for-c-or-python-users","text":"Reelay requires Boost C++ libraries at several places. In particular, we heavily use Boost Interval Container Library (ICL) inside timed monitors. Below is a list of how to install Boost for several environments: For Debian/Ubuntu: apt install -y libboost-all-dev For CentOS/Fedora: yum install -y boost-devel For Arch/Manjaro: pacman -S boost For MacOS (assuming homebrew installed): brew install boost Note that we mainly develop Reelay on Ubuntu 18.04 therefore it's the most tested environment among these environments. For Windows machines, we suggest installing Reelay on Ubuntu 18.04 on Windows Subsystem for Linux (WSL).","title":"2) Boost C++ Libraries (for C++ or Python users)"},{"location":"install/#3-cudd-library-only-for-c-users","text":"Reelay data monitors additionally require CUDD binary decision diagram (BDD) library. If CUDD library is not installed on your system, please see the next section how to build CUDD from the source.","title":"3) CUDD Library (only for C++ users)"},{"location":"install/#4-pybind11-only-for-python-users","text":"To use Reelay in Python, we additionaly require the package pybind11 that provides seamless operability between C++11 and Python. python -m pip install pybind11 This command also install pybind11 package and required C++ header files such as pybind11/pybind11.h and pybind11/stl.h .","title":"4) Pybind11 (only for Python users)"},{"location":"install/#install-reelay-c-library","text":"This section describe the installation steps on Ubuntu 18.04. First, clone the reelay repository and its submodules using --recursive flag as follows: git clone https://github.com/doganulus/reelay.git --recurse-submodules cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Finally you can build and install CUDD library by typing: make cudd sudo make cudd-install These commands will build the shared library libcudd.so and place it under /usr/local/lib directory by default. Programs that use Reelay data monitors have to link this library at the compilation.","title":"Install Reelay C++ Library"},{"location":"install/#install-reelay-python-package","text":"A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: python -m pip install reelay The command above will install latest release of Reelay. Here python executable could be any python3 executable as Reelay is tested from 3.5 to the latest 3.8 . Alternatively you can install the development version of Reelay from the master branch directly. python -m pip install git+https://github.com/doganulus/reelay.git This command will build the extension module from the source therefore it may take longer to install. Finally Python installation handles the CUDD dependency automatically and you do not need to install CUDD if you are only interested in using Reelay from Python.","title":"Install Reelay Python Package"},{"location":"license/","text":"The Reelay project is licensed under the MPL 2.0 . The MPL 2.0 is a simple copyleft license. The MPL's \"file-level\" copyleft is designed to encourage contributors to share modifications they make to your code, while still allowing them to combine your code with code under other licenses (open or proprietary) with minimal restrictions. Please also check frequently asked questions and answers about using and distributing code under the MPL 2.0 from here .","title":"License"},{"location":"literature/","text":"Academic Literature Here is the list of eleven papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Efficient robust monitoring for STL by Alexandre Donze, Thomas Ferrere, and Oded Maler. 2013. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"References"},{"location":"literature/#academic-literature","text":"Here is the list of eleven papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Efficient robust monitoring for STL by Alexandre Donze, Thomas Ferrere, and Oded Maler. 2013. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Academic Literature"},{"location":"naming/","text":"Naming The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"naming/#naming","text":"The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"past_temporal_logic/","text":"Past Temporal Logic Temporal signals Expression syntax Construct Syntax Examples Explanation Atomic Expressions Propositions {key} { lights_on } lights_on is a Boolean variable over time. Numerical Comparison Predicates { key < const } { key <= const } { key > const } { key >= const } { speed < 30m/s} { temperature > 10*C} speed and temperature are numerical variables over time. Custom Predicates $ fname $ my_predicate User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not {lights_on} Conjunction and , && { speed > 10m/s} and { speed < 30m/s} Disjunction or , || Implication implies , -> { lights_on } implies { speed < 30m/s} Temporal Expressions Previously pre , Y pre { lights_on } It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once { lights_on } The expression once { lights_on } is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] { lights_on } The expression once[a:b] { lights_on } is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically { lights_on } The expression historically { lights_on } is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] { lights_on } The expression historically[a:b] { lights_on } is true at the current time point if lights were always on between b and a time units before now. Since since , S { speed < 30} since { lights_on } The expression { speed < 30} since { lights_on } is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] { speed < 30} since[a:b] { lights_on } The expression { speed < 30} since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#past-temporal-logic","text":"","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#temporal-signals","text":"","title":"Temporal signals"},{"location":"past_temporal_logic/#expression-syntax","text":"Construct Syntax Examples Explanation Atomic Expressions Propositions {key} { lights_on } lights_on is a Boolean variable over time. Numerical Comparison Predicates { key < const } { key <= const } { key > const } { key >= const } { speed < 30m/s} { temperature > 10*C} speed and temperature are numerical variables over time. Custom Predicates $ fname $ my_predicate User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not {lights_on} Conjunction and , && { speed > 10m/s} and { speed < 30m/s} Disjunction or , || Implication implies , -> { lights_on } implies { speed < 30m/s} Temporal Expressions Previously pre , Y pre { lights_on } It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once { lights_on } The expression once { lights_on } is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] { lights_on } The expression once[a:b] { lights_on } is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically { lights_on } The expression historically { lights_on } is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] { lights_on } The expression historically[a:b] { lights_on } is true at the current time point if lights were always on between b and a time units before now. Since since , S { speed < 30} since { lights_on } The expression { speed < 30} since { lights_on } is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] { speed < 30} since[a:b] { lights_on } The expression { speed < 30} since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Expression syntax"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmarking"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"python_api/","text":"Running Reelay from Python","title":"Python API"},{"location":"python_api/#running-reelay-from-python","text":"","title":"Running Reelay from Python"},{"location":"regular_expressions/","text":"(Under construction)","title":"Regular expressions"},{"location":"release_notes/","text":"(Under construction)","title":"Release notes"},{"location":"rye/","text":"Reelay Expression Format Reelay reads executable specifications written in plain text and verifies that the system does what those specifications say at runtime. To construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Rye format for short. What is Rye Format? Rye format uses a set of special constructs (that is, keywords and punctuation) to describe desired system behavior over temporal data streams expressed in structured data formats like multiline JSON or CSV. These syntactic constructs are divided into four categories: Atomic expressions Boolean logic expressions Temporal logic expressions Regular expressions (in a future release) Let's start with atomic expressions. Atomic Expressions Atomic expressions are the basic building blocks of Reelay expressions. Basic atoms use the curly-bracket syntax {...} and describes a set of constraints over data objects. For example, an atomic expression such as {lights_on: true, speed > 20.0, mode: \"Sport XL\"} will be evaluated to true for time points 101 and 102 below over a temporal behavior given as a sequence of JSON objects such that ... { \"time\" : 101 , \"lights_on\" : true , \"speed\" : 21.23 , \"mode\" : \"Sport XL\" } { \"time\" : 102 , \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Sport XL\" } { \"time\" : 103 , \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Sport XL\" } ... Currently Reelay supports Booleans ( true , false ), numerical comparisons ( < , <= , > , >= , == , != ), string equivalences inside curly atoms over data objects. Non-existent or unspecified field names in data objects and their values do not change the value of the atomic expression. For example, an atomic expression such as {speed > 21.0} will be evaluated to true for the time point 101 and false for time points 102 and 103 regardless of the value of other fields in the objects. For the case where you require that a field exists in the object but don't care about its value, Reelay uses the asterisk ( * ) symbol to denote that any value is acceptable. For example, {lights_on: true, speed > 19.0, mode: *} will be evaluated to true for time points 101 , 102 , and 103 but to false for a data object { \"time\" : 104 , \"lights_on\" : true , \"speed\" : 21.23 } since it does not contain any field named as mode . Quite often we have to deal with complex hierarchial data objects such as ... { \"time\" : 104 , \"ego\" : { \"lights_on\" : true , \"motion\" : { \"position\" : [ 117.2 , -345.7 ], \"speed\" : 21.23 } } } .. when monitoring real-time systems. Therefore, Reelay support hierarchical atoms and uses :: operator to specify the path of hierarchy as follows: ego::motion::{speed > 21.0} These path will be calculated from the current namespace, and initially from the root of the main data object. Reelay also provides a limited support for array-like structures and currently allows the specification of indices using $index syntax such that ego::motion::position::{$0 > 100.0, $1 > 0.0} As usual we use zero-based indexing in our specifications. Finally Reelay allows to declare categorical variable references inside atoms using the *ref_name syntax such that {lights_on: true, speed > 20, mode: *myref} Then this reference called myref can be used elsewhere in the expression and quantified by exists and forall operators. More details regarding these operators are given in the following section of logical constructs. Boolean Logic Expressions This section describe Boolean logic operations over atomic Reelay expressions. we mainly use curly atoms in the examples but these constructs are equally applicable unless anything noted. Negation The negation of Reelay expressions is defined by using keywords not and ! . not {key1: value1, key2: value2} Conjunction The conjuction of Reelay expressions is defined by using keywords and and && . One can see that atomic expression syntax is a shortcut for conjunction between atomic constraints. Two Reelay expressions below are functionally equivalent: {key1: value1, key2: value2} and {key1: value1} and {key2: value2} Disjunction The disjunction of constraints has to defined explicitly using keywords or and || . {key1: value1} or {key2: value2} Logical Implication Logical implication is a popular Boolean operation when writing conditional specifications. The logical implication of constraints has to defined explicitly using keywords implies and -> . {key1: value1} -> {key2: value2} References and Quantifiers The ability to refer to data values (unknown at compile time) is one of the advanced features of Reelay. Roughly speaking, a reference variable acts a memory location where many data values (from a key) can be stored and can be checked later (or with another key) for the equality. Then these data values can quantified for existence ( exists ) and universality ( forall ). Note that this feature is currently supported for categorical variables (e.g. strings) only. The syntax for references and quantifiers is as follows: exists[ref1, ref2, ...]. RYE(ref1, ref2, ...) forall[ref1, ref2, ...]. RYE(ref1, ref2, ...) where RYE(ref1, ref2, ...) is an arbitrary Reelay expression that contains reference declarations ref1, ref2, ... inside its atoms. For example, we may want to check the equality of data values for two fields but don't know or cannot write all possible cases at compile time. exists[refname]. {key1: *refname, key2: *refname} This expression above will be evaluated to true for the data object { \"key1\" : \"hello\" , \"key2\" : \"hello\" } but false for the data object { \"key1\" : \"hello\" , \"key2\" : \"world\" } as two string values are not equal in the latter. More advanced use of references involve temporal expressions explained in the following sections, which allow us checking data values from different time points. Temporal Logic Expressions Previously The unary operation of previously is defined using keywords pre and Y . For example, consider the Reelay expression pre{lights_on: true} which is true at the current time point if lights were on in the previous time point. Note that previously operation is only meaningful for untimed and discrete timed settings but dense timed settings. Sometime in the Past, Once The unary operation of once is defined using keywords once and P . For example, consider the Reelay expression once{lights_on: true} which is true at the current time point if lights were on in sometime in the past. It is possible to add timing constraints to the specification such that once[a:b]{lights_on: true} which is true at the current time point if lights were always on in sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively. Always in the Past, Historically The unary operation of historically is defined using keywords historically and H . For example, consider the Reelay expression historically{lights_on: true} which is true at the current time point if lights were on in some time in the past. It is possible to add timing constraints to the specification such that historically[a:b]{lights_on: true} which is true at the current time point if lights were always on between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively. Since The binary operation of since is defined using keywords since and S . For example, consider the Reelay expression {speed < 30} since {lights_on: true} which is true at the current time point if the variable speed is always less than 30 units since lights_on is true last time. It is possible to add timing constraints to the specification such that {speed < 30} since[a:b] {lights_on: true} which is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively. A Note regarding Operator Precedence As a rule of thumb, unary operators bind stronger than binary operators (except quantifiers, better use parantheses) and unary operators are eagerly matching therefore an expression such as not {...} since {...} would be parsed as (not {...}) since {...} and not as not ({...} since {...})","title":"Rye Format"},{"location":"rye/#reelay-expression-format","text":"Reelay reads executable specifications written in plain text and verifies that the system does what those specifications say at runtime. To construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Rye format for short.","title":"Reelay Expression Format"},{"location":"rye/#what-is-rye-format","text":"Rye format uses a set of special constructs (that is, keywords and punctuation) to describe desired system behavior over temporal data streams expressed in structured data formats like multiline JSON or CSV. These syntactic constructs are divided into four categories: Atomic expressions Boolean logic expressions Temporal logic expressions Regular expressions (in a future release) Let's start with atomic expressions.","title":"What is Rye Format?"},{"location":"rye/#atomic-expressions","text":"Atomic expressions are the basic building blocks of Reelay expressions. Basic atoms use the curly-bracket syntax {...} and describes a set of constraints over data objects. For example, an atomic expression such as {lights_on: true, speed > 20.0, mode: \"Sport XL\"} will be evaluated to true for time points 101 and 102 below over a temporal behavior given as a sequence of JSON objects such that ... { \"time\" : 101 , \"lights_on\" : true , \"speed\" : 21.23 , \"mode\" : \"Sport XL\" } { \"time\" : 102 , \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Sport XL\" } { \"time\" : 103 , \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Sport XL\" } ... Currently Reelay supports Booleans ( true , false ), numerical comparisons ( < , <= , > , >= , == , != ), string equivalences inside curly atoms over data objects. Non-existent or unspecified field names in data objects and their values do not change the value of the atomic expression. For example, an atomic expression such as {speed > 21.0} will be evaluated to true for the time point 101 and false for time points 102 and 103 regardless of the value of other fields in the objects. For the case where you require that a field exists in the object but don't care about its value, Reelay uses the asterisk ( * ) symbol to denote that any value is acceptable. For example, {lights_on: true, speed > 19.0, mode: *} will be evaluated to true for time points 101 , 102 , and 103 but to false for a data object { \"time\" : 104 , \"lights_on\" : true , \"speed\" : 21.23 } since it does not contain any field named as mode . Quite often we have to deal with complex hierarchial data objects such as ... { \"time\" : 104 , \"ego\" : { \"lights_on\" : true , \"motion\" : { \"position\" : [ 117.2 , -345.7 ], \"speed\" : 21.23 } } } .. when monitoring real-time systems. Therefore, Reelay support hierarchical atoms and uses :: operator to specify the path of hierarchy as follows: ego::motion::{speed > 21.0} These path will be calculated from the current namespace, and initially from the root of the main data object. Reelay also provides a limited support for array-like structures and currently allows the specification of indices using $index syntax such that ego::motion::position::{$0 > 100.0, $1 > 0.0} As usual we use zero-based indexing in our specifications. Finally Reelay allows to declare categorical variable references inside atoms using the *ref_name syntax such that {lights_on: true, speed > 20, mode: *myref} Then this reference called myref can be used elsewhere in the expression and quantified by exists and forall operators. More details regarding these operators are given in the following section of logical constructs.","title":"Atomic Expressions"},{"location":"rye/#boolean-logic-expressions","text":"This section describe Boolean logic operations over atomic Reelay expressions. we mainly use curly atoms in the examples but these constructs are equally applicable unless anything noted.","title":"Boolean Logic Expressions"},{"location":"rye/#negation","text":"The negation of Reelay expressions is defined by using keywords not and ! . not {key1: value1, key2: value2}","title":"Negation"},{"location":"rye/#conjunction","text":"The conjuction of Reelay expressions is defined by using keywords and and && . One can see that atomic expression syntax is a shortcut for conjunction between atomic constraints. Two Reelay expressions below are functionally equivalent: {key1: value1, key2: value2} and {key1: value1} and {key2: value2}","title":"Conjunction"},{"location":"rye/#disjunction","text":"The disjunction of constraints has to defined explicitly using keywords or and || . {key1: value1} or {key2: value2}","title":"Disjunction"},{"location":"rye/#logical-implication","text":"Logical implication is a popular Boolean operation when writing conditional specifications. The logical implication of constraints has to defined explicitly using keywords implies and -> . {key1: value1} -> {key2: value2}","title":"Logical Implication"},{"location":"rye/#references-and-quantifiers","text":"The ability to refer to data values (unknown at compile time) is one of the advanced features of Reelay. Roughly speaking, a reference variable acts a memory location where many data values (from a key) can be stored and can be checked later (or with another key) for the equality. Then these data values can quantified for existence ( exists ) and universality ( forall ). Note that this feature is currently supported for categorical variables (e.g. strings) only. The syntax for references and quantifiers is as follows: exists[ref1, ref2, ...]. RYE(ref1, ref2, ...) forall[ref1, ref2, ...]. RYE(ref1, ref2, ...) where RYE(ref1, ref2, ...) is an arbitrary Reelay expression that contains reference declarations ref1, ref2, ... inside its atoms. For example, we may want to check the equality of data values for two fields but don't know or cannot write all possible cases at compile time. exists[refname]. {key1: *refname, key2: *refname} This expression above will be evaluated to true for the data object { \"key1\" : \"hello\" , \"key2\" : \"hello\" } but false for the data object { \"key1\" : \"hello\" , \"key2\" : \"world\" } as two string values are not equal in the latter. More advanced use of references involve temporal expressions explained in the following sections, which allow us checking data values from different time points.","title":"References and Quantifiers"},{"location":"rye/#temporal-logic-expressions","text":"","title":"Temporal Logic Expressions"},{"location":"rye/#previously","text":"The unary operation of previously is defined using keywords pre and Y . For example, consider the Reelay expression pre{lights_on: true} which is true at the current time point if lights were on in the previous time point. Note that previously operation is only meaningful for untimed and discrete timed settings but dense timed settings.","title":"Previously"},{"location":"rye/#sometime-in-the-past-once","text":"The unary operation of once is defined using keywords once and P . For example, consider the Reelay expression once{lights_on: true} which is true at the current time point if lights were on in sometime in the past. It is possible to add timing constraints to the specification such that once[a:b]{lights_on: true} which is true at the current time point if lights were always on in sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively.","title":"Sometime in the Past, Once"},{"location":"rye/#always-in-the-past-historically","text":"The unary operation of historically is defined using keywords historically and H . For example, consider the Reelay expression historically{lights_on: true} which is true at the current time point if lights were on in some time in the past. It is possible to add timing constraints to the specification such that historically[a:b]{lights_on: true} which is true at the current time point if lights were always on between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively.","title":"Always in the Past, Historically"},{"location":"rye/#since","text":"The binary operation of since is defined using keywords since and S . For example, consider the Reelay expression {speed < 30} since {lights_on: true} which is true at the current time point if the variable speed is always less than 30 units since lights_on is true last time. It is possible to add timing constraints to the specification such that {speed < 30} since[a:b] {lights_on: true} which is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively.","title":"Since"},{"location":"rye/#a-note-regarding-operator-precedence","text":"As a rule of thumb, unary operators bind stronger than binary operators (except quantifiers, better use parantheses) and unary operators are eagerly matching therefore an expression such as not {...} since {...} would be parsed as (not {...}) since {...} and not as not ({...} since {...})","title":"A Note regarding Operator Precedence"},{"location":"sequential_networks/","text":"(Under construction)","title":"Sequential networks"}]}