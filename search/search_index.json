{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reelay Monitors Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase. Features Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line Rye Format Reelay reads executable specifications written in plain text and verifies at runtime that the system does what those specifications describe. In order to construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Reelay Expression (Rye) format. See Rye format reference for more details. Get Started The next steps for you are to install Reelay from source or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ , Python , and the command line interface . Contribute Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Home"},{"location":"#reelay-monitors","text":"Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase.","title":"Reelay Monitors"},{"location":"#features","text":"Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line","title":"Features"},{"location":"#rye-format","text":"Reelay reads executable specifications written in plain text and verifies at runtime that the system does what those specifications describe. In order to construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Reelay Expression (Rye) format. See Rye format reference for more details.","title":"Rye Format"},{"location":"#get-started","text":"The next steps for you are to install Reelay from source or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ , Python , and the command line interface .","title":"Get Started"},{"location":"#contribute","text":"Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Contribute"},{"location":"author/","text":"Dogan Ulus Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Author"},{"location":"author/#dogan-ulus","text":"Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Dogan Ulus"},{"location":"behaviors/","text":"(Under construction)","title":"Behaviors"},{"location":"cpp_api/","text":"(Under construction)","title":"C++ API"},{"location":"docker/","text":"Running Reelay in a Docker container This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl '{p1} since[18:24] {p2}' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Docker Image"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl '{p1} since[18:24] {p2}' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Running Reelay in a Docker container"},{"location":"gs_cli/","text":"Getting Started From Terminal (Under construction)","title":"Getting Started From Terminal"},{"location":"gs_cli/#getting-started-from-terminal","text":"(Under construction)","title":"Getting Started From Terminal"},{"location":"gs_cpp/","text":"Getting Started From C++ In this part, we show how to instatiate and execute Reelay monitors in C++ given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay C++ Library and Recipes The core component of Reelay is a header-only template library for C++ supporting several specification languages. Templates allow to customize monitors for different input types (e.g std::tuple or std::map ) or different time types (e.g. int64_t or double ). In this tutorial, we will use Reelay recipes, a predefined selection of concrete monitor classes that instatiates monitor templates by convenient datatypes. We include Reelay recipes into our source file as follows: #include \"reelay/recipes.hpp\" Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name input_t time_t Gaps in behaviors reelay::past_ltl_monitor std::map<std::string, bool> - No reelay::past_mtl_monitor std::map<std::string, int64_t> int64_t Yes reelay::discrete_timed_past_mtl_monitor std::map<std::string, int64_t> int64_t No reelay::past_stl_monitor std::map<std::string, double> double Yes reelay::discrete_timed_past_stl_monitor std::map<std::string, double> int64_t No Please also check the User Manual for the information regarding reelay/recipes.hpp as well as reelay/monitors.hpp , which provide a nice interface for full datatype customization of monitors. We provide further information on time models and temporal logics under advanced topics. Check Requirements over System Behaviors Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. using input_t = std :: map < std :: string , int64_t > ; std :: vector < input_t > correct_sys_behavior = std :: vector < input_t > (); correct_sys_behavior . push_back ( input_t {{ \"time\" , 1 }, { \"door_open\" , 0 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 2 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 3 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 4 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 5 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 6 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 7 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 1 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 8 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 9 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: auto my_monitor_1 = reelay :: discrete_timed_past_mtl_monitor ( \"(historically[0:5]{door_open} and not{dow_suppressed}) -> { door_open_warning } \"); The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for ( const auto & message : correct_sys_behavior ) { auto check_1 = my_monitor_1 . update ( message ); if ( not check_1 ) { std :: cout << \"Error at time \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all. Inserting an Error (Under construction) Time Gaps in Behaviors (Under construction)","title":"Use Reelay from C++"},{"location":"gs_cpp/#getting-started-from-c","text":"In this part, we show how to instatiate and execute Reelay monitors in C++ given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From C++"},{"location":"gs_cpp/#reelay-c-library-and-recipes","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. Templates allow to customize monitors for different input types (e.g std::tuple or std::map ) or different time types (e.g. int64_t or double ). In this tutorial, we will use Reelay recipes, a predefined selection of concrete monitor classes that instatiates monitor templates by convenient datatypes. We include Reelay recipes into our source file as follows: #include \"reelay/recipes.hpp\" Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name input_t time_t Gaps in behaviors reelay::past_ltl_monitor std::map<std::string, bool> - No reelay::past_mtl_monitor std::map<std::string, int64_t> int64_t Yes reelay::discrete_timed_past_mtl_monitor std::map<std::string, int64_t> int64_t No reelay::past_stl_monitor std::map<std::string, double> double Yes reelay::discrete_timed_past_stl_monitor std::map<std::string, double> int64_t No Please also check the User Manual for the information regarding reelay/recipes.hpp as well as reelay/monitors.hpp , which provide a nice interface for full datatype customization of monitors. We provide further information on time models and temporal logics under advanced topics.","title":"Reelay C++ Library and Recipes"},{"location":"gs_cpp/#check-requirements-over-system-behaviors","text":"Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. using input_t = std :: map < std :: string , int64_t > ; std :: vector < input_t > correct_sys_behavior = std :: vector < input_t > (); correct_sys_behavior . push_back ( input_t {{ \"time\" , 1 }, { \"door_open\" , 0 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 2 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 3 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 4 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 5 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 6 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 7 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 1 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 8 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 9 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: auto my_monitor_1 = reelay :: discrete_timed_past_mtl_monitor ( \"(historically[0:5]{door_open} and not{dow_suppressed}) -> { door_open_warning } \"); The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for ( const auto & message : correct_sys_behavior ) { auto check_1 = my_monitor_1 . update ( message ); if ( not check_1 ) { std :: cout << \"Error at time \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all.","title":"Check Requirements over System Behaviors"},{"location":"gs_cpp/#inserting-an-error","text":"(Under construction)","title":"Inserting an Error"},{"location":"gs_cpp/#time-gaps-in-behaviors","text":"(Under construction)","title":"Time Gaps in Behaviors"},{"location":"gs_intro/","text":"Tutorial: Introduction This initial part of the tutorial is about why we have system requirements and how to write them in the specification languages that Reelay support. The remaining parts will about how to check these specifications over temporal streams using Reelay . Let\u2019s start with an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature! An Example Feature So we want to design a feature that warns the user whenever our robot detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another tutorial. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into testable system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: An example behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... The next sections will be about writing these requirements in a non-ambigious (and executable) specification language and checking them over such system behaviors. Specify Requirements In this tutorial, we will use Reelay Expression (RYE) format to specify our requirements. RYE format is a temporal logic based formal language commonly used to describe temporal patterns over signals in a precise and non-ambigious manner. Reelay can compile RYE specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in RYE: (historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning} The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b]{cond} tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5]{door_open} is true if door_open is always true from 5 minutes ago to now . The reference for Reelay expression format is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. {door_open_warning} -> historically[0:5]{door_open} {door_open_warning} -> not{dow_suppressed} Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . {door_open_warning} -> not(pre({door_open} since {door_open_warning})) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5]{door_open} and not {dow_suppressed}) -> door_open_warning False Negative SYS-REQ-01 {door_open_warning} -> historically[0:5]{door_open} False Positive SYS-REQ-01 {door_open_warning} -> not{dow_suppressed} False Positive SYS-REQ-02 {door_open_warning} -> not(pre({door_open} since {door_open_warning})) False Positive Check Requirements Reelay has been designed for flexibility and efficiency in mind so that users can embed fast runtime monitoring for their projects in C++ or Python as well as use them standalone from the command line. Following tutorials will explain how to check these requirements using Reelay monitors over behaviors of the system. Check requirements from C++ Check requirements from Python Check requirements from CLI","title":"Tutorial: Introduction"},{"location":"gs_intro/#tutorial-introduction","text":"This initial part of the tutorial is about why we have system requirements and how to write them in the specification languages that Reelay support. The remaining parts will about how to check these specifications over temporal streams using Reelay . Let\u2019s start with an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature!","title":"Tutorial: Introduction"},{"location":"gs_intro/#an-example-feature","text":"So we want to design a feature that warns the user whenever our robot detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another tutorial. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into testable system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: An example behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... The next sections will be about writing these requirements in a non-ambigious (and executable) specification language and checking them over such system behaviors.","title":"An Example Feature"},{"location":"gs_intro/#specify-requirements","text":"In this tutorial, we will use Reelay Expression (RYE) format to specify our requirements. RYE format is a temporal logic based formal language commonly used to describe temporal patterns over signals in a precise and non-ambigious manner. Reelay can compile RYE specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in RYE: (historically[0:5]{door_open} and not {dow_suppressed}) -> {door_open_warning} The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b]{cond} tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5]{door_open} is true if door_open is always true from 5 minutes ago to now . The reference for Reelay expression format is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. {door_open_warning} -> historically[0:5]{door_open} {door_open_warning} -> not{dow_suppressed} Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . {door_open_warning} -> not(pre({door_open} since {door_open_warning})) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5]{door_open} and not {dow_suppressed}) -> door_open_warning False Negative SYS-REQ-01 {door_open_warning} -> historically[0:5]{door_open} False Positive SYS-REQ-01 {door_open_warning} -> not{dow_suppressed} False Positive SYS-REQ-02 {door_open_warning} -> not(pre({door_open} since {door_open_warning})) False Positive","title":"Specify Requirements"},{"location":"gs_intro/#check-requirements","text":"Reelay has been designed for flexibility and efficiency in mind so that users can embed fast runtime monitoring for their projects in C++ or Python as well as use them standalone from the command line. Following tutorials will explain how to check these requirements using Reelay monitors over behaviors of the system. Check requirements from C++ Check requirements from Python Check requirements from CLI","title":"Check Requirements"},{"location":"gs_python/","text":"Getting Started From Python Warning Reelay Python API is in its early stage. Everthing in this page is subject to change. In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay Python Package The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay recipes that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these recipes together with a thin layer of Pythonic user interface. In this tutorial, we will use Reelay Python package imported into your project as follows: import reelay Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name Expected input type Default Time Model reelay.past_ltl.monitor dict[str, bool] N/A reelay.past_mtl.monitor dict[str, int] discrete reelay.past_stl.monitor dict[str, float] dense Please also check the User Manual for the information regarding Python API. We provide further information on time models and temporal logics under advanced topics. Check Requirements over System Behaviors Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. correct_sys_behavior = [ dict ( time = 1 , door_open = False , dow_suppressed = False , door_open_warning = False ), dict ( time = 2 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 3 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 4 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 5 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 6 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 7 , door_open = True , dow_suppressed = False , door_open_warning = True ), dict ( time = 8 , door_open = True , dow_suppressed = True , door_open_warning = False ), dict ( time = 9 , door_open = True , dow_suppressed = True , door_open_warning = False ), ] The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: my_monitor_1 = reelay . past_mtl . monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} -> \" \"door_open_warning\" , time_model = \"discrete\" ) The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for message in correct_sys_behavior : check_1 = my_monitor_1 . update ( message ) if not check_1 : print ( 'Error at time {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all. Inserting an Error (Under construction) Time Gaps in Behaviors (Under construction)","title":"Use Reelay from Python"},{"location":"gs_python/#getting-started-from-python","text":"Warning Reelay Python API is in its early stage. Everthing in this page is subject to change. In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From Python"},{"location":"gs_python/#reelay-python-package","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay recipes that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these recipes together with a thin layer of Pythonic user interface. In this tutorial, we will use Reelay Python package imported into your project as follows: import reelay Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name Expected input type Default Time Model reelay.past_ltl.monitor dict[str, bool] N/A reelay.past_mtl.monitor dict[str, int] discrete reelay.past_stl.monitor dict[str, float] dense Please also check the User Manual for the information regarding Python API. We provide further information on time models and temporal logics under advanced topics.","title":"Reelay Python Package"},{"location":"gs_python/#check-requirements-over-system-behaviors","text":"Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. correct_sys_behavior = [ dict ( time = 1 , door_open = False , dow_suppressed = False , door_open_warning = False ), dict ( time = 2 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 3 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 4 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 5 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 6 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 7 , door_open = True , dow_suppressed = False , door_open_warning = True ), dict ( time = 8 , door_open = True , dow_suppressed = True , door_open_warning = False ), dict ( time = 9 , door_open = True , dow_suppressed = True , door_open_warning = False ), ] The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: my_monitor_1 = reelay . past_mtl . monitor ( pattern = r \"(historically[0:5] {door_open} and not {dow_suppressed} -> \" \"door_open_warning\" , time_model = \"discrete\" ) The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for message in correct_sys_behavior : check_1 = my_monitor_1 . update ( message ) if not check_1 : print ( 'Error at time {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all.","title":"Check Requirements over System Behaviors"},{"location":"gs_python/#inserting-an-error","text":"(Under construction)","title":"Inserting an Error"},{"location":"gs_python/#time-gaps-in-behaviors","text":"(Under construction)","title":"Time Gaps in Behaviors"},{"location":"install/","text":"Install Dependencies 1) C++11 Compiler (for C++ or Python users) Reelay requires a C++ compiler compliant with C++11 standard. Today all major compiler frameworks already provide full C++11 support. We mainly use gcc and sometimes clang for additional analyses (e.g. extra warnings). 2) Boost C++ Libraries (for C++ or Python users) Reelay requires Boost C++ libraries at several places. In particular, we heavily use Boost Interval Container Library (ICL) inside timed monitors. Below is a list of how to install Boost for several environments: For Debian/Ubuntu: apt install -y libboost-all-dev For CentOS/Fedora: yum install -y boost-devel For Arch/Manjaro: pacman -S boost For MacOS (assuming homebrew installed): brew install boost Note that we mainly develop Reelay on Ubuntu 18.04 therefore it's the most tested environment among these environments. For Windows machines, we suggest installing Reelay on Ubuntu 18.04 on Windows Subsystem for Linux (WSL). 3) CUDD Library (only for C++ users) Reelay data monitors additionally require CUDD binary decision diagram (BDD) library. If CUDD library is not installed on your system, please see the next section how to build CUDD from the source. 4) Pybind11 (only for Python users) To use Reelay in Python, we additionaly require the package pybind11 that provides seamless operability between C++11 and Python. python -m pip install pybind11 This command also install pybind11 package and required C++ header files such as pybind11/pybind11.h and pybind11/stl.h . Install Reelay C++ Library This section describe the installation steps on Ubuntu 18.04. First, clone the reelay repository and its submodules using --recursive flag as follows: git clone https://github.com/doganulus/reelay.git --recurse-submodules cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Finally you can build and install CUDD library by typing: make cudd sudo make cudd-install These commands will build the shared library libcudd.so and place it under /usr/local/lib directory by default. Programs that use Reelay data monitors have to link this library at the compilation. Install Reelay Python Package A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: python -m pip install reelay The command above will install latest release of Reelay. Here python executable could be any python3 executable as Reelay is tested from 3.5 to the latest 3.8 . Alternatively you can install the development version of Reelay from the master branch directly. python -m pip install git+https://github.com/doganulus/reelay.git This command will build the extension module from the source therefore it may take longer to install. Finally Python installation handles the CUDD dependency automatically and you do not need to install CUDD if you are only interested in using Reelay from Python.","title":"From Source"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#dependencies","text":"","title":"Dependencies"},{"location":"install/#1-c11-compiler-for-c-or-python-users","text":"Reelay requires a C++ compiler compliant with C++11 standard. Today all major compiler frameworks already provide full C++11 support. We mainly use gcc and sometimes clang for additional analyses (e.g. extra warnings).","title":"1) C++11 Compiler (for C++ or Python users)"},{"location":"install/#2-boost-c-libraries-for-c-or-python-users","text":"Reelay requires Boost C++ libraries at several places. In particular, we heavily use Boost Interval Container Library (ICL) inside timed monitors. Below is a list of how to install Boost for several environments: For Debian/Ubuntu: apt install -y libboost-all-dev For CentOS/Fedora: yum install -y boost-devel For Arch/Manjaro: pacman -S boost For MacOS (assuming homebrew installed): brew install boost Note that we mainly develop Reelay on Ubuntu 18.04 therefore it's the most tested environment among these environments. For Windows machines, we suggest installing Reelay on Ubuntu 18.04 on Windows Subsystem for Linux (WSL).","title":"2) Boost C++ Libraries (for C++ or Python users)"},{"location":"install/#3-cudd-library-only-for-c-users","text":"Reelay data monitors additionally require CUDD binary decision diagram (BDD) library. If CUDD library is not installed on your system, please see the next section how to build CUDD from the source.","title":"3) CUDD Library (only for C++ users)"},{"location":"install/#4-pybind11-only-for-python-users","text":"To use Reelay in Python, we additionaly require the package pybind11 that provides seamless operability between C++11 and Python. python -m pip install pybind11 This command also install pybind11 package and required C++ header files such as pybind11/pybind11.h and pybind11/stl.h .","title":"4) Pybind11 (only for Python users)"},{"location":"install/#install-reelay-c-library","text":"This section describe the installation steps on Ubuntu 18.04. First, clone the reelay repository and its submodules using --recursive flag as follows: git clone https://github.com/doganulus/reelay.git --recurse-submodules cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Finally you can build and install CUDD library by typing: make cudd sudo make cudd-install These commands will build the shared library libcudd.so and place it under /usr/local/lib directory by default. Programs that use Reelay data monitors have to link this library at the compilation.","title":"Install Reelay C++ Library"},{"location":"install/#install-reelay-python-package","text":"A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: python -m pip install reelay The command above will install latest release of Reelay. Here python executable could be any python3 executable as Reelay is tested from 3.5 to the latest 3.8 . Alternatively you can install the development version of Reelay from the master branch directly. python -m pip install git+https://github.com/doganulus/reelay.git This command will build the extension module from the source therefore it may take longer to install. Finally Python installation handles the CUDD dependency automatically and you do not need to install CUDD if you are only interested in using Reelay from Python.","title":"Install Reelay Python Package"},{"location":"license/","text":"The Reelay project is licensed under the MPL 2.0 . The MPL 2.0 is a simple copyleft license. The MPL's \"file-level\" copyleft is designed to encourage contributors to share modifications they make to your code, while still allowing them to combine your code with code under other licenses (open or proprietary) with minimal restrictions. Please also check frequently asked questions and answers about using and distributing code under the MPL 2.0 from here .","title":"License"},{"location":"literature/","text":"Literature Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"References"},{"location":"literature/#literature","text":"Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Literature"},{"location":"naming/","text":"Naming The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"naming/#naming","text":"The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"past_temporal_logic/","text":"Past Temporal Logic Temporal signals Expression syntax Construct Syntax Examples Explanation Atomic Expressions Propositions {key} { lights_on } lights_on is a Boolean variable over time. Numerical Comparison Predicates { key < const } { key <= const } { key > const } { key >= const } { speed < 30m/s} { temperature > 10*C} speed and temperature are numerical variables over time. Custom Predicates $ fname $ my_predicate User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not {lights_on} Conjunction and , && { speed > 10m/s} and { speed < 30m/s} Disjunction or , || Implication implies , -> { lights_on } implies { speed < 30m/s} Temporal Expressions Previously pre , Y pre { lights_on } It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once { lights_on } The expression once { lights_on } is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] { lights_on } The expression once[a:b] { lights_on } is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically { lights_on } The expression historically { lights_on } is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] { lights_on } The expression historically[a:b] { lights_on } is true at the current time point if lights were always on between b and a time units before now. Since since , S { speed < 30} since { lights_on } The expression { speed < 30} since { lights_on } is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] { speed < 30} since[a:b] { lights_on } The expression { speed < 30} since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#past-temporal-logic","text":"","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#temporal-signals","text":"","title":"Temporal signals"},{"location":"past_temporal_logic/#expression-syntax","text":"Construct Syntax Examples Explanation Atomic Expressions Propositions {key} { lights_on } lights_on is a Boolean variable over time. Numerical Comparison Predicates { key < const } { key <= const } { key > const } { key >= const } { speed < 30m/s} { temperature > 10*C} speed and temperature are numerical variables over time. Custom Predicates $ fname $ my_predicate User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not {lights_on} Conjunction and , && { speed > 10m/s} and { speed < 30m/s} Disjunction or , || Implication implies , -> { lights_on } implies { speed < 30m/s} Temporal Expressions Previously pre , Y pre { lights_on } It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once { lights_on } The expression once { lights_on } is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] { lights_on } The expression once[a:b] { lights_on } is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically { lights_on } The expression historically { lights_on } is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] { lights_on } The expression historically[a:b] { lights_on } is true at the current time point if lights were always on between b and a time units before now. Since since , S { speed < 30} since { lights_on } The expression { speed < 30} since { lights_on } is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] { speed < 30} since[a:b] { lights_on } The expression { speed < 30} since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Expression syntax"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmarking"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"python_api/","text":"Running Reelay from Python","title":"Python API"},{"location":"python_api/#running-reelay-from-python","text":"","title":"Running Reelay from Python"},{"location":"regular_expressions/","text":"(Under construction)","title":"Regular Expressions"},{"location":"release_notes/","text":"(Under construction)","title":"Release Notes"},{"location":"rye/","text":"Reelay Expression Format Reelay reads executable specifications written in plain text and verifies that the system does what those specifications say at runtime. To construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Rye format in short. What is Rye Format? Rye format uses a set of special constructs (that is, keywords and punctuation) to describe desired system behavior over temporal data streams expressed in JSON Lines or CSV-like formats. These constructs are divided into four categories: Atomic expressions Boolean logic expressions Temporal logic expressions Regular expressions (soon) Let's start with atomic expressions. Atomic Expressions Atomic expressions are the basic building blocks of Reelay expressions. Atomic expressions in Reelay come in two flavors: (1) curly-bracketed atoms {...} for streams of key-value pairs (JSON, CSV with header, etc.) and (2) square-bracketed atoms [...] for streams of list-like (CSV without header, space-delimited logs, etc.). The choice depends on the streaming format and these two flavors should not be mixed naturally. Each atom describes a set of constraints over data elements. For example, a curly-bracketed atom is written such that {lights_on: true, speed > 20, mode: \"Sport XL\"} and will be evaluated to true for time points 101 and 102 below over a temporal behavior given as a JSON object such that ... { \"time\" : 101 , \"lights_on\" : true , \"speed\" : 21.23 , \"mode\" : \"Sport XL\" } { \"time\" : 102 , \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Sport XL\" } { \"time\" : 103 , \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Sport XL\" } ... Currently Reelay supports Booleans ( true , false ), numerical comparisons ( < , <= , > , >= , == , != ), string equivalences inside curly atoms over flat data objects. The support for hierarchical (dotted) keys will be added in a future release for hierarchical data objects. Over list-like streams, we may write the same requirement, [true, * > 20, \"Sport XL\"] where the order of elements and the length must match the specification in this case except that the first element reserved for timestamp information. For example, this expression would be true only for the time point 101 below: ... 101, true, 21.23, \"Sport XL\" 102, true, 20.01, \"Sport XL\", 121 103, true, 19.12, \"Sport XL\" ... Timing aspects and specification has a special focus in Reelay. Currently we exclusively use time field for dict-like objects and the first element of a list-like object for timestamp information. This behavior can be generalized in future releases. Reelay atomic expressions accepts * as a dummy placeholder for field values. For example, the last two column is ignored in the specification below. It will be evalutated to true for time points 101 adn 103 as it still need to match the length. [true, *, *] For curly atoms, this construct allows you to describe the case where you require the key exist in the object but don't care about its value. {lights_on: true, speed: *, mode: *} Finally Reelay allows to declare categorical variable references inside atoms using *ref_name syntax such that {lights_on: true, speed > 20, mode: *m} and [true, speed > 20, mode: *myref] This reference called myref than can be used elsewhere in the expression and quantified by exists and forall operators. More details regarding these operators are given in the following section. Boolean Logic Expressions This section describle Boolean logic operations over atomic Reelay expressions. we mainly use curly atoms in the examples but these constructs are equally applicable unless anything noted. Negation The negation of Reelay expressions is defined by using keywords not and ! . not {key1: value1, key2: value2} Conjunction The conjuction of Reelay expressions is defined by using keywords and and && . One can see that atomic expression syntax is a shortcut for conjunction between atomic constraints. It is true that two Reelay expressions below are functionally equivalent: {key1: value1, key2: value2} and {key1: value1} and {key2: value2} For square atoms, however, one should be careful about lengths. Then two Reelay expressions below are functionally equivalent. [value1, value2] and [value1, *] and [*, value2] Disjunction The disjunction of constraints has to defined explicitly using keywords or and || . {key1: value1} or {key2: value2} Logical Implication Logical implication is a popular Boolean operation when writing conditional specifications. The logical implication of constraints has to defined explicitly using keywords implies and -> . {key1: value1} -> {key2: value2} References and Quantifiers The ability to refer to data values (unknown at compile time) is one of the advanced features of Reelay. Roughly speaking, a reference variable acts a memory location where many data values (from a key) can be stored and can be checked later (or with another key) for the equality. Then these data values can quantified for existence ( exists ) and universality ( forall ). Note that this feature is currently supported for categorical variables (e.g. strings) only. The syntax for references and quantifiers is as follows: exists[ref1, ref2, ...]. RYE(ref1, ref2, ...) forall[ref1, ref2, ...]. RYE(ref1, ref2, ...) where RYE(ref1, ref2, ...) is an arbitrary Reelay expression that contains reference declarations ref1, ref2, ... inside its atoms. For example, we may want to check the equality of data values for two fields but don't know or cannot write all possible cases at compile time. exists[refname]. {key1: *refname, key2: *refname} This expression above will be evaluated to true for the data object { \"key1\" : \"hello\" , \"key2\" : \"hello\" } but false for the data object { \"key1\" : \"hello\" , \"key2\" : \"world\" } as two string values are not equal in the latter. More advanced use of references involve temporal expressions explained in the following sections, which allow us checking data values from different time points. Temporal Logic Expressions Previously The unary operation of previously is defined using keywords pre and Y . For example, consider the Reelay expression pre{lights_on: true} which is true at the current time point if lights were on in the previous time point. Note that previously operation is only meaningful for untimed and discrete timed settings but dense timed settings. Sometime in the Past, Once The unary operation of once is defined using keywords once and P . For example, consider the Reelay expression once{lights_on: true} which is true at the current time point if lights were on in sometime in the past. It is possible to add timing constraints to the specification such that once[a:b]{lights_on: true} which is true at the current time point if lights were always on in sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively. Always in the Past, Historically The unary operation of historically is defined using keywords historically and H . For example, consider the Reelay expression historically{lights_on: true} which is true at the current time point if lights were on in some time in the past. It is possible to add timing constraints to the specification such that historically[a:b]{lights_on: true} which is true at the current time point if lights were always on between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively. Since The binary operation of since is defined using keywords since and S . For example, consider the Reelay expression {speed < 30} since {lights_on: true} which is true at the current time point if the variable speed is always less than 30 units since lights_on is true last time. It is possible to add timing constraints to the specification such that {speed < 30} since[a:b] {lights_on: true} which is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively. Regular Expressions Union Concatenation Repetition Duration Constraints Intersection A Note regarding Operator Precedence As a rule of thumb, unary operators bind stronger than binary operators (except quantifiers, better use parantheses) and unary operators are eagerly matching therefore an expression such as not {...} since {...} would be parsed as (not {...}) since {...} and not as not ({...} since {...})","title":"Rye Format"},{"location":"rye/#reelay-expression-format","text":"Reelay reads executable specifications written in plain text and verifies that the system does what those specifications say at runtime. To construct runtime monitors automatically, those specifications must follow some basic syntax rules, called Rye format in short.","title":"Reelay Expression Format"},{"location":"rye/#what-is-rye-format","text":"Rye format uses a set of special constructs (that is, keywords and punctuation) to describe desired system behavior over temporal data streams expressed in JSON Lines or CSV-like formats. These constructs are divided into four categories: Atomic expressions Boolean logic expressions Temporal logic expressions Regular expressions (soon) Let's start with atomic expressions.","title":"What is Rye Format?"},{"location":"rye/#atomic-expressions","text":"Atomic expressions are the basic building blocks of Reelay expressions. Atomic expressions in Reelay come in two flavors: (1) curly-bracketed atoms {...} for streams of key-value pairs (JSON, CSV with header, etc.) and (2) square-bracketed atoms [...] for streams of list-like (CSV without header, space-delimited logs, etc.). The choice depends on the streaming format and these two flavors should not be mixed naturally. Each atom describes a set of constraints over data elements. For example, a curly-bracketed atom is written such that {lights_on: true, speed > 20, mode: \"Sport XL\"} and will be evaluated to true for time points 101 and 102 below over a temporal behavior given as a JSON object such that ... { \"time\" : 101 , \"lights_on\" : true , \"speed\" : 21.23 , \"mode\" : \"Sport XL\" } { \"time\" : 102 , \"lights_on\" : true , \"speed\" : 20.01 , \"mode\" : \"Sport XL\" } { \"time\" : 103 , \"lights_on\" : true , \"speed\" : 19.12 , \"mode\" : \"Sport XL\" } ... Currently Reelay supports Booleans ( true , false ), numerical comparisons ( < , <= , > , >= , == , != ), string equivalences inside curly atoms over flat data objects. The support for hierarchical (dotted) keys will be added in a future release for hierarchical data objects. Over list-like streams, we may write the same requirement, [true, * > 20, \"Sport XL\"] where the order of elements and the length must match the specification in this case except that the first element reserved for timestamp information. For example, this expression would be true only for the time point 101 below: ... 101, true, 21.23, \"Sport XL\" 102, true, 20.01, \"Sport XL\", 121 103, true, 19.12, \"Sport XL\" ... Timing aspects and specification has a special focus in Reelay. Currently we exclusively use time field for dict-like objects and the first element of a list-like object for timestamp information. This behavior can be generalized in future releases. Reelay atomic expressions accepts * as a dummy placeholder for field values. For example, the last two column is ignored in the specification below. It will be evalutated to true for time points 101 adn 103 as it still need to match the length. [true, *, *] For curly atoms, this construct allows you to describe the case where you require the key exist in the object but don't care about its value. {lights_on: true, speed: *, mode: *} Finally Reelay allows to declare categorical variable references inside atoms using *ref_name syntax such that {lights_on: true, speed > 20, mode: *m} and [true, speed > 20, mode: *myref] This reference called myref than can be used elsewhere in the expression and quantified by exists and forall operators. More details regarding these operators are given in the following section.","title":"Atomic Expressions"},{"location":"rye/#boolean-logic-expressions","text":"This section describle Boolean logic operations over atomic Reelay expressions. we mainly use curly atoms in the examples but these constructs are equally applicable unless anything noted.","title":"Boolean Logic Expressions"},{"location":"rye/#negation","text":"The negation of Reelay expressions is defined by using keywords not and ! . not {key1: value1, key2: value2}","title":"Negation"},{"location":"rye/#conjunction","text":"The conjuction of Reelay expressions is defined by using keywords and and && . One can see that atomic expression syntax is a shortcut for conjunction between atomic constraints. It is true that two Reelay expressions below are functionally equivalent: {key1: value1, key2: value2} and {key1: value1} and {key2: value2} For square atoms, however, one should be careful about lengths. Then two Reelay expressions below are functionally equivalent. [value1, value2] and [value1, *] and [*, value2]","title":"Conjunction"},{"location":"rye/#disjunction","text":"The disjunction of constraints has to defined explicitly using keywords or and || . {key1: value1} or {key2: value2}","title":"Disjunction"},{"location":"rye/#logical-implication","text":"Logical implication is a popular Boolean operation when writing conditional specifications. The logical implication of constraints has to defined explicitly using keywords implies and -> . {key1: value1} -> {key2: value2}","title":"Logical Implication"},{"location":"rye/#references-and-quantifiers","text":"The ability to refer to data values (unknown at compile time) is one of the advanced features of Reelay. Roughly speaking, a reference variable acts a memory location where many data values (from a key) can be stored and can be checked later (or with another key) for the equality. Then these data values can quantified for existence ( exists ) and universality ( forall ). Note that this feature is currently supported for categorical variables (e.g. strings) only. The syntax for references and quantifiers is as follows: exists[ref1, ref2, ...]. RYE(ref1, ref2, ...) forall[ref1, ref2, ...]. RYE(ref1, ref2, ...) where RYE(ref1, ref2, ...) is an arbitrary Reelay expression that contains reference declarations ref1, ref2, ... inside its atoms. For example, we may want to check the equality of data values for two fields but don't know or cannot write all possible cases at compile time. exists[refname]. {key1: *refname, key2: *refname} This expression above will be evaluated to true for the data object { \"key1\" : \"hello\" , \"key2\" : \"hello\" } but false for the data object { \"key1\" : \"hello\" , \"key2\" : \"world\" } as two string values are not equal in the latter. More advanced use of references involve temporal expressions explained in the following sections, which allow us checking data values from different time points.","title":"References and Quantifiers"},{"location":"rye/#temporal-logic-expressions","text":"","title":"Temporal Logic Expressions"},{"location":"rye/#previously","text":"The unary operation of previously is defined using keywords pre and Y . For example, consider the Reelay expression pre{lights_on: true} which is true at the current time point if lights were on in the previous time point. Note that previously operation is only meaningful for untimed and discrete timed settings but dense timed settings.","title":"Previously"},{"location":"rye/#sometime-in-the-past-once","text":"The unary operation of once is defined using keywords once and P . For example, consider the Reelay expression once{lights_on: true} which is true at the current time point if lights were on in sometime in the past. It is possible to add timing constraints to the specification such that once[a:b]{lights_on: true} which is true at the current time point if lights were always on in sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively.","title":"Sometime in the Past, Once"},{"location":"rye/#always-in-the-past-historically","text":"The unary operation of historically is defined using keywords historically and H . For example, consider the Reelay expression historically{lights_on: true} which is true at the current time point if lights were on in some time in the past. It is possible to add timing constraints to the specification such that historically[a:b]{lights_on: true} which is true at the current time point if lights were always on between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively.","title":"Always in the Past, Historically"},{"location":"rye/#since","text":"The binary operation of since is defined using keywords since and S . For example, consider the Reelay expression {speed < 30} since {lights_on: true} which is true at the current time point if the variable speed is always less than 30 units since lights_on is true last time. It is possible to add timing constraints to the specification such that {speed < 30} since[a:b] {lights_on: true} which is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. We use the syntax [a:] and [:b] if there is no constraints on upper and lower bounds, respectively.","title":"Since"},{"location":"rye/#regular-expressions","text":"","title":"Regular Expressions"},{"location":"rye/#union","text":"","title":"Union"},{"location":"rye/#concatenation","text":"","title":"Concatenation"},{"location":"rye/#repetition","text":"","title":"Repetition"},{"location":"rye/#duration-constraints","text":"","title":"Duration Constraints"},{"location":"rye/#intersection","text":"","title":"Intersection"},{"location":"rye/#a-note-regarding-operator-precedence","text":"As a rule of thumb, unary operators bind stronger than binary operators (except quantifiers, better use parantheses) and unary operators are eagerly matching therefore an expression such as not {...} since {...} would be parsed as (not {...}) since {...} and not as not ({...} since {...})","title":"A Note regarding Operator Precedence"},{"location":"sequential_networks/","text":"(Under construction)","title":"Sequential Networks"},{"location":"specification/","text":"(Under construction)","title":"Specification"},{"location":"time_models/","text":"(Under construction)","title":"Time Models"}]}