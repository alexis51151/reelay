{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reelay Monitors Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase. Features Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line Get Started The next steps for you are to install Reelay from source or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ , Python , and the command line interface . Contribute Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Home"},{"location":"#reelay-monitors","text":"Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase.","title":"Reelay Monitors"},{"location":"#features","text":"Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line","title":"Features"},{"location":"#get-started","text":"The next steps for you are to install Reelay from source or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ , Python , and the command line interface .","title":"Get Started"},{"location":"#contribute","text":"Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Contribute"},{"location":"author/","text":"Dogan Ulus Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Author"},{"location":"author/#dogan-ulus","text":"Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Dogan Ulus"},{"location":"behaviors/","text":"(Under construction)","title":"Temporal Behaviors"},{"location":"cpp_api/","text":"(Under construction)","title":"C++ API"},{"location":"docker/","text":"Running Reelay in a Docker container This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Docker Image"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Running Reelay in a Docker container"},{"location":"gs_cli/","text":"Getting Started From Terminal (Under construction)","title":"Use Reelay from CLI"},{"location":"gs_cli/#getting-started-from-terminal","text":"(Under construction)","title":"Getting Started From Terminal"},{"location":"gs_cpp/","text":"Getting Started From C++ In this part, we show how to instatiate and execute Reelay monitors in C++ given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay C++ Library and Recipes The core component of Reelay is a header-only template library for C++ supporting several specification languages. Templates allow to customize monitors for different input types (e.g std::tuple or std::map ) or different time types (e.g. int64_t or double ). In this tutorial, we will use Reelay recipes, a predefined selection of concrete monitor classes that instatiates monitor templates by convenient datatypes. We include Reelay recipes into our source file as follows: #include \"reelay/recipes.hpp\" Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name input_t time_t Gaps in behaviors reelay::past_ltl_monitor std::map<std::string, bool> - No reelay::past_mtl_monitor std::map<std::string, int64_t> int64_t Yes reelay::discrete_timed_past_mtl_monitor std::map<std::string, int64_t> int64_t No reelay::past_stl_monitor std::map<std::string, double> double Yes reelay::discrete_timed_past_stl_monitor std::map<std::string, double> int64_t No Please also check the User Manual for the information regarding reelay/recipes.hpp as well as reelay/monitors.hpp , which provide a nice interface for full datatype customization of monitors. We provide further information on time models and temporal logics under advanced topics. Check Requirements over System Behaviors Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. using input_t = std :: map < std :: string , int64_t > ; std :: vector < input_t > correct_sys_behavior = std :: vector < input_t > (); correct_sys_behavior . push_back ( input_t {{ \"time\" , 1 }, { \"door_open\" , 0 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 2 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 3 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 4 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 5 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 6 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 7 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 1 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 8 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 9 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: auto my_monitor_1 = reelay :: discrete_timed_past_mtl_monitor ( \"(historically[0:5](door_open) and not dow_suppressed) -> door_open_warning\" ); The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for ( const auto & message : correct_sys_behavior ) { auto check_1 = my_monitor_1 . update ( message ); if ( not check_1 ) { std :: cout << \"Error at time \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all. Inserting an Error (Under construction) Time Gaps in Behaviors (Under construction)","title":"Use Reelay from C++"},{"location":"gs_cpp/#getting-started-from-c","text":"In this part, we show how to instatiate and execute Reelay monitors in C++ given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From C++"},{"location":"gs_cpp/#reelay-c-library-and-recipes","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. Templates allow to customize monitors for different input types (e.g std::tuple or std::map ) or different time types (e.g. int64_t or double ). In this tutorial, we will use Reelay recipes, a predefined selection of concrete monitor classes that instatiates monitor templates by convenient datatypes. We include Reelay recipes into our source file as follows: #include \"reelay/recipes.hpp\" Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name input_t time_t Gaps in behaviors reelay::past_ltl_monitor std::map<std::string, bool> - No reelay::past_mtl_monitor std::map<std::string, int64_t> int64_t Yes reelay::discrete_timed_past_mtl_monitor std::map<std::string, int64_t> int64_t No reelay::past_stl_monitor std::map<std::string, double> double Yes reelay::discrete_timed_past_stl_monitor std::map<std::string, double> int64_t No Please also check the User Manual for the information regarding reelay/recipes.hpp as well as reelay/monitors.hpp , which provide a nice interface for full datatype customization of monitors. We provide further information on time models and temporal logics under advanced topics.","title":"Reelay C++ Library and Recipes"},{"location":"gs_cpp/#check-requirements-over-system-behaviors","text":"Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. using input_t = std :: map < std :: string , int64_t > ; std :: vector < input_t > correct_sys_behavior = std :: vector < input_t > (); correct_sys_behavior . push_back ( input_t {{ \"time\" , 1 }, { \"door_open\" , 0 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 2 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 3 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 4 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 5 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 6 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 7 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 0 }, { \"door_open_warning\" , 1 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 8 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); correct_sys_behavior . push_back ( input_t {{ \"time\" , 9 }, { \"door_open\" , 1 }, { \"dow_suppressed\" , 1 }, { \"door_open_warning\" , 0 }} ); The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: auto my_monitor_1 = reelay :: discrete_timed_past_mtl_monitor ( \"(historically[0:5](door_open) and not dow_suppressed) -> door_open_warning\" ); The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for ( const auto & message : correct_sys_behavior ) { auto check_1 = my_monitor_1 . update ( message ); if ( not check_1 ) { std :: cout << \"Error at time \" << my_monitor_1 . now () << \" : False negative detected (SYS-REQ-01 Violation)\" << std :: endl ; } } The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all.","title":"Check Requirements over System Behaviors"},{"location":"gs_cpp/#inserting-an-error","text":"(Under construction)","title":"Inserting an Error"},{"location":"gs_cpp/#time-gaps-in-behaviors","text":"(Under construction)","title":"Time Gaps in Behaviors"},{"location":"gs_intro/","text":"Tutorial: Introduction This initial part of the tutorial is about why we have system requirements and how to write them in the specification languages that Reelay support. The remaining parts will about how to check these specifications over temporal streams using Reelay . Let\u2019s start with an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature! An Example Feature So we want to design a feature that warns the user whenever our robot detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another tutorial. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into testable system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: An example behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... The next sections will be about writing these requirements in a non-ambigious (and executable) specification language and checking them over such system behaviors. Specify Requirements In this tutorial, we will use Past Temporal Logic (PTL) to specify our requirements. Temporal logics such as PTL are commonly used to describe temporal patterns over signals in a precise and non-ambigious manner. Reelay can compile PTL specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in PTL: (historically[0:5](door_open) and not dow_suppressed) -> door_open_warning The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b](cond) tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5](door_open) is true if door_open is always true from 5 minutes ago to now . The cheatsheet for PTL is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. door_open_warning -> historically[0:5](door_open) door_open_warning1 -> not dow_suppressed Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . door_open_warning -> not(pre(door_open since door_open_warning)) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:5](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive Check Requirements Reelay has been designed for flexibility and efficiency in mind so that users can embed fast runtime monitoring for their projects in C++ or Python as well as use them standalone from the command line. Following tutorials will explain how to check these requirements using Reelay monitors over behaviors of the system. Check requirements from C++ Check requirements from Python Check requirements from CLI","title":"Tutorial: Introduction"},{"location":"gs_intro/#tutorial-introduction","text":"This initial part of the tutorial is about why we have system requirements and how to write them in the specification languages that Reelay support. The remaining parts will about how to check these specifications over temporal streams using Reelay . Let\u2019s start with an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature!","title":"Tutorial: Introduction"},{"location":"gs_intro/#an-example-feature","text":"So we want to design a feature that warns the user whenever our robot detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another tutorial. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into testable system requirements. Perhaps we would want to issue a warning after some time, say 5 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open at least 5 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our second requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: An example behavior of the system would be a sequence of observations (data) as follows: time (mins) door_open dow_suppressed door_open_warning 1 False False False 2 True False False 3 True False False 4 True False False 5 True False False 6 True False False 7 True False True 8 True True False 9 True True False ... ... ... ... The next sections will be about writing these requirements in a non-ambigious (and executable) specification language and checking them over such system behaviors.","title":"An Example Feature"},{"location":"gs_intro/#specify-requirements","text":"In this tutorial, we will use Past Temporal Logic (PTL) to specify our requirements. Temporal logics such as PTL are commonly used to describe temporal patterns over signals in a precise and non-ambigious manner. Reelay can compile PTL specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open at least 5 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in PTL: (historically[0:5](door_open) and not dow_suppressed) -> door_open_warning The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b](cond) tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:5](door_open) is true if door_open is always true from 5 minutes ago to now . The cheatsheet for PTL is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. door_open_warning -> historically[0:5](door_open) door_open_warning1 -> not dow_suppressed Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . door_open_warning -> not(pre(door_open since door_open_warning)) This specification means that, whenever door_open_warning is true, door_open should not be continuously true since the last time door_open_warning is true. Therefore, the specification capture the intended meaning of SYS-REQ-02 and its violation would be considered as a false positive. To conclude, let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:5](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:5](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive","title":"Specify Requirements"},{"location":"gs_intro/#check-requirements","text":"Reelay has been designed for flexibility and efficiency in mind so that users can embed fast runtime monitoring for their projects in C++ or Python as well as use them standalone from the command line. Following tutorials will explain how to check these requirements using Reelay monitors over behaviors of the system. Check requirements from C++ Check requirements from Python Check requirements from CLI","title":"Check Requirements"},{"location":"gs_python/","text":"Getting Started From Python Warning Reelay Python API is in its early stage. Everthing in this page is subject to change. In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here . Reelay Python Package The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay recipes that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these recipes together with a thin layer of Pythonic user interface. In this tutorial, we will use Reelay Python package imported into your project as follows: import reelay Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name Expected input type Default Time Model reelay.past_ltl.monitor dict[str, bool] N/A reelay.past_mtl.monitor dict[str, int] discrete reelay.past_stl.monitor dict[str, float] dense Please also check the User Manual for the information regarding Python API. We provide further information on time models and temporal logics under advanced topics. Check Requirements over System Behaviors Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. correct_sys_behavior = [ dict ( time = 1 , door_open = False , dow_suppressed = False , door_open_warning = False ), dict ( time = 2 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 3 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 4 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 5 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 6 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 7 , door_open = True , dow_suppressed = False , door_open_warning = True ), dict ( time = 8 , door_open = True , dow_suppressed = True , door_open_warning = False ), dict ( time = 9 , door_open = True , dow_suppressed = True , door_open_warning = False ), ] The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: my_monitor_1 = reelay . past_mtl . monitor ( pattern = \"(historically[0:5](door_open) and not dow_suppressed) -> \" \"door_open_warning\" , time_model = \"discrete\" ) The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for message in correct_sys_behavior : check_1 = my_monitor_1 . update ( message ) if not check_1 : print ( 'Error at time {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all. Inserting an Error (Under construction) Time Gaps in Behaviors (Under construction)","title":"Use Reelay from Python"},{"location":"gs_python/#getting-started-from-python","text":"Warning Reelay Python API is in its early stage. Everthing in this page is subject to change. In this part, we show how to instatiate and execute Reelay monitors from Python given formal specifications. These monitors would observe the system behavior and report violations at runtime. First recall our specifications for the Door Open Warning (DOW) feature of a home assistant robot as explained in the introduction . The source code of this tutorial can be found here .","title":"Getting Started From Python"},{"location":"gs_python/#reelay-python-package","text":"The core component of Reelay is a header-only template library for C++ supporting several specification languages. In C++ tutorial , we introduced Reelay recipes that instantiate template classes with concrete datatypes. Reelay Python package is essentially Python bindings of these recipes together with a thin layer of Pythonic user interface. In this tutorial, we will use Reelay Python package imported into your project as follows: import reelay Some of these recipes are given below in the table together with predefined datatypes. Main differences between these monitor classes are the time model, either discrete or dense (roughly meaning-- might have time gaps between samples), and the input type whether we monitor Boolean signals (as in past_ltl_monitor ) or numerical signals (as in past_stl_monitor ). Class Name Expected input type Default Time Model reelay.past_ltl.monitor dict[str, bool] N/A reelay.past_mtl.monitor dict[str, int] discrete reelay.past_stl.monitor dict[str, float] dense Please also check the User Manual for the information regarding Python API. We provide further information on time models and temporal logics under advanced topics.","title":"Reelay Python Package"},{"location":"gs_python/#check-requirements-over-system-behaviors","text":"Let's put correct system behavior into a container for demo purposes. Later we will read one-by-one it as if it comes from a real-time system. correct_sys_behavior = [ dict ( time = 1 , door_open = False , dow_suppressed = False , door_open_warning = False ), dict ( time = 2 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 3 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 4 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 5 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 6 , door_open = True , dow_suppressed = False , door_open_warning = False ), dict ( time = 7 , door_open = True , dow_suppressed = False , door_open_warning = True ), dict ( time = 8 , door_open = True , dow_suppressed = True , door_open_warning = False ), dict ( time = 9 , door_open = True , dow_suppressed = True , door_open_warning = False ), ] The use of reelay monitors is pretty straighforward and we construct an online monitor for our first specification as follows: my_monitor_1 = reelay . past_mtl . monitor ( pattern = \"(historically[0:5](door_open) and not dow_suppressed) -> \" \"door_open_warning\" , time_model = \"discrete\" ) The rest of the program reads the system behavior incrementally and feeds the monitor accordingly. for message in correct_sys_behavior : check_1 = my_monitor_1 . update ( message ) if not check_1 : print ( 'Error at time {err_time} : False negative detected (SYS-REQ-01 Violation)' . format ( err_time = my_monitor_1 . now ())) The monitor would return false if it detects a violation then the program print an error message. When checking correct_sys_behavior , we will not see any error as the behavior satisfies the requirement. In the next section, however, we will insert some errors into the behavior and Reelay monitors would catch them all.","title":"Check Requirements over System Behaviors"},{"location":"gs_python/#inserting-an-error","text":"(Under construction)","title":"Inserting an Error"},{"location":"gs_python/#time-gaps-in-behaviors","text":"(Under construction)","title":"Time Gaps in Behaviors"},{"location":"install/","text":"Install Reelay C++ Library Reelay is tested on the latest Ubuntu LTS (18.04). A fresh Ubuntu installation at least requires the installation of following packages: sudo apt-get update sudo apt-get install -y libboost-all-dev Then, clone the reelay repository: git clone https://github.com/doganulus/reelay.git cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Now you can include reelay monitors in your C++ project! #include \"reelay/monitors.hpp\" Please also check the apps folder for more information on the usage. Reelay Python Package A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: make python Currently past LTL, past MTL, and past STL monitors are available from Python over discrete and dense time signals. Please check example python files . Reelay Apps The following command will compile and install command-line applications using reelay library to monitor formal specifications over CSV files: make apps sudo make apps-install Currently available applications are rymtl for past MTL specifications and rystl for past STL specifications.","title":"From Source"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#reelay-c-library","text":"Reelay is tested on the latest Ubuntu LTS (18.04). A fresh Ubuntu installation at least requires the installation of following packages: sudo apt-get update sudo apt-get install -y libboost-all-dev Then, clone the reelay repository: git clone https://github.com/doganulus/reelay.git cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Now you can include reelay monitors in your C++ project! #include \"reelay/monitors.hpp\" Please also check the apps folder for more information on the usage.","title":"Reelay C++ Library"},{"location":"install/#reelay-python-package","text":"A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: make python Currently past LTL, past MTL, and past STL monitors are available from Python over discrete and dense time signals. Please check example python files .","title":"Reelay Python Package"},{"location":"install/#reelay-apps","text":"The following command will compile and install command-line applications using reelay library to monitor formal specifications over CSV files: make apps sudo make apps-install Currently available applications are rymtl for past MTL specifications and rystl for past STL specifications.","title":"Reelay Apps"},{"location":"license/","text":"The Reelay project is licensed under the MPL 2.0 . The MPL 2.0 is a simple copyleft license. The MPL's \"file-level\" copyleft is designed to encourage contributors to share modifications they make to your code, while still allowing them to combine your code with code under other licenses (open or proprietary) with minimal restrictions. Please also check frequently asked questions and answers about using and distributing code under the MPL 2.0 from here .","title":"License"},{"location":"literature/","text":"Literature Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"References"},{"location":"literature/#literature","text":"Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Literature"},{"location":"motivation/","text":"Why","title":"Why"},{"location":"motivation/#why","text":"","title":"Why"},{"location":"naming/","text":"Naming The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"naming/#naming","text":"The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"past_temporal_logic/","text":"Past Temporal Logic Temporal signals Expression syntax Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. Commonly used patterns Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"PTL Cheatsheet"},{"location":"past_temporal_logic/#past-temporal-logic","text":"","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#temporal-signals","text":"","title":"Temporal signals"},{"location":"past_temporal_logic/#expression-syntax","text":"Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Expression syntax"},{"location":"past_temporal_logic/#commonly-used-patterns","text":"Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"Commonly used patterns"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmarking"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"python_api/","text":"Running Reelay from Python","title":"Python API"},{"location":"python_api/#running-reelay-from-python","text":"","title":"Running Reelay from Python"},{"location":"regular_expressions/","text":"(Under construction)","title":"Regular Expressions"},{"location":"release_notes/","text":"(Under construction)","title":"Release Notes"},{"location":"sequential_networks/","text":"(Under construction)","title":"Sequential Networks"},{"location":"specification/","text":"(Under construction)","title":"Formal Specifications"},{"location":"time_models/","text":"(Under construction)","title":"Time Models"}]}