{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"docker/","text":"Running Reelay in a Docker container This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Docker"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Running Reelay in a Docker container"},{"location":"literature/","text":"Literature Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Literature"},{"location":"literature/#literature","text":"Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Literature"},{"location":"past_temporal_logic/","text":"Past Temporal Logic Temporal signals Expression syntax Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. Commonly used patterns Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#past-temporal-logic","text":"","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#temporal-signals","text":"","title":"Temporal signals"},{"location":"past_temporal_logic/#expression-syntax","text":"Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Expression syntax"},{"location":"past_temporal_logic/#commonly-used-patterns","text":"Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"Commonly used patterns"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmark Results"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"python_api/","text":"Running Reelay from Python","title":"Running Reelay from Python"},{"location":"python_api/#running-reelay-from-python","text":"","title":"Running Reelay from Python"}]}