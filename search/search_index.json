{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reelay Monitors Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase. Features Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line Get Started The next steps for you are to install Reelay from source or Docker image and follow through tutorials to learn how to use Reelay monitors from C++ , Python and the command line interface . Contribute Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Home"},{"location":"#reelay-monitors","text":"Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase.","title":"Reelay Monitors"},{"location":"#features","text":"Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line","title":"Features"},{"location":"#get-started","text":"The next steps for you are to install Reelay from source or Docker image and follow through tutorials to learn how to use Reelay monitors from C++ , Python and the command line interface .","title":"Get Started"},{"location":"#contribute","text":"Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Contribute"},{"location":"author/","text":"Dogan Ulus Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He successfully defended his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Author"},{"location":"author/#dogan-ulus","text":"Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He successfully defended his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Dogan Ulus"},{"location":"docker/","text":"Running Reelay in a Docker container This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Docker Image"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Running Reelay in a Docker container"},{"location":"gs_cli/","text":"Getting Started From Terminal (Under construction)","title":"CLI Tutorial"},{"location":"gs_cli/#getting-started-from-terminal","text":"(Under construction)","title":"Getting Started From Terminal"},{"location":"gs_cpp/","text":"Getting Started From C++ Reelay has been designed for efficiency and flexibility so that users can write their applications in C++ or embed formal specification monitoring into their projects easily. #include \"reelay/recipes.hpp\" The use of reelay monitors is pretty straighforward and we construct an online monitor for a past temporal logic formula as follows: auto my_monitor = reelay::past_ltl_monitor(\"grant -> once(request)\"); for (const auto &current_input : input_sequence) { my_monitor->update(current_input); // feed with current input current_output = my_monitor->output(); // obtain the current output } Since this is a property that should be true at each and every time point The ability to construct discrete and dense timed monitors from timed specifications is the main goal and feature of reelay project. We construct online monitor from such specification as follows: auto my_monitor = reelay::discrete_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); auto my_monitor = reelay::dense_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); From the online monitoring point of view, the essential difference between discrete and dense time models is the duration of updates, which is strictly one time unit for the discrete setting whereas it could be arbitrarily long or short for the dense setting. For more information, please check discrete and dense timed settings. These settings are usually called metric temporal logic (MTL) and very popular for specifiying properties of real-time/cyber-physical systems.","title":"C++ Tutorial"},{"location":"gs_cpp/#getting-started-from-c","text":"Reelay has been designed for efficiency and flexibility so that users can write their applications in C++ or embed formal specification monitoring into their projects easily. #include \"reelay/recipes.hpp\" The use of reelay monitors is pretty straighforward and we construct an online monitor for a past temporal logic formula as follows: auto my_monitor = reelay::past_ltl_monitor(\"grant -> once(request)\"); for (const auto &current_input : input_sequence) { my_monitor->update(current_input); // feed with current input current_output = my_monitor->output(); // obtain the current output } Since this is a property that should be true at each and every time point The ability to construct discrete and dense timed monitors from timed specifications is the main goal and feature of reelay project. We construct online monitor from such specification as follows: auto my_monitor = reelay::discrete_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); auto my_monitor = reelay::dense_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); From the online monitoring point of view, the essential difference between discrete and dense time models is the duration of updates, which is strictly one time unit for the discrete setting whereas it could be arbitrarily long or short for the dense setting. For more information, please check discrete and dense timed settings. These settings are usually called metric temporal logic (MTL) and very popular for specifiying properties of real-time/cyber-physical systems.","title":"Getting Started From C++"},{"location":"gs_intro/","text":"Getting Started with An Example Suppose that we design a home assistant robot having a feature that warns the user whenever he detects the entry door left open. We want to ensure that our robot gives multiple warnings in a short time, which may annoy our customers. Requirement SYS-REQ-01: Requirement SYS-REQ-02: Following tutorial will explain how to check these specifications C++ Tutorial Python Tutorial CLI Tutorial","title":"An Example"},{"location":"gs_intro/#getting-started-with-an-example","text":"Suppose that we design a home assistant robot having a feature that warns the user whenever he detects the entry door left open. We want to ensure that our robot gives multiple warnings in a short time, which may annoy our customers. Requirement SYS-REQ-01: Requirement SYS-REQ-02: Following tutorial will explain how to check these specifications C++ Tutorial Python Tutorial CLI Tutorial","title":"Getting Started with An Example"},{"location":"gs_python/","text":"Getting Started From Python (Under construction)","title":"Python Tutorial"},{"location":"gs_python/#getting-started-from-python","text":"(Under construction)","title":"Getting Started From Python"},{"location":"install/","text":"Install from Source Reelay C++ Library Reelay is tested on the latest Ubuntu LTS (18.04). A fresh Ubuntu installation at least requires the installation of following packages: sudo apt-get update sudo apt-get install -y libboost-all-dev Then, clone the reelay repository: git clone https://github.com/doganulus/reelay.git cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Now you can include reelay monitors in your C++ project! #include \"reelay/monitors.hpp\" Please also check the apps folder for more information on the usage. Reelay Python Package A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: make python Currently past LTL, past MTL, and past STL monitors are available from Python over discrete and dense time signals. Please check example python files . Reelay Monitoring Apps The following command will compile and install command-line applications using reelay library to monitor formal specifications over CSV files: make apps sudo make apps-install Currently available applications are rymtl for past MTL specifications and rystl for past STL specifications.","title":"From Source"},{"location":"install/#install-from-source","text":"","title":"Install from Source"},{"location":"install/#reelay-c-library","text":"Reelay is tested on the latest Ubuntu LTS (18.04). A fresh Ubuntu installation at least requires the installation of following packages: sudo apt-get update sudo apt-get install -y libboost-all-dev Then, clone the reelay repository: git clone https://github.com/doganulus/reelay.git cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Now you can include reelay monitors in your C++ project! #include \"reelay/monitors.hpp\" Please also check the apps folder for more information on the usage.","title":"Reelay C++ Library"},{"location":"install/#reelay-python-package","text":"A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: make python Currently past LTL, past MTL, and past STL monitors are available from Python over discrete and dense time signals. Please check example python files .","title":"Reelay Python Package"},{"location":"install/#reelay-monitoring-apps","text":"The following command will compile and install command-line applications using reelay library to monitor formal specifications over CSV files: make apps sudo make apps-install Currently available applications are rymtl for past MTL specifications and rystl for past STL specifications.","title":"Reelay Monitoring Apps"},{"location":"license/","text":"The Reelay project is licensed under the MPL 2.0 . The MPL 2.0 is a simple copyleft license. The MPL's \"file-level\" copyleft is designed to encourage contributors to share modifications they make to your code, while still allowing them to combine your code with code under other licenses (open or proprietary) with minimal restrictions. Please also check frequently asked questions and answers about using and distributing code under the MPL 2.0 from here .","title":"License"},{"location":"literature/","text":"Literature Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"References"},{"location":"literature/#literature","text":"Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Literature"},{"location":"motivation/","text":"Why","title":"Motivation"},{"location":"motivation/#why","text":"","title":"Why"},{"location":"naming/","text":"Naming The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"naming/#naming","text":"The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"past_temporal_logic/","text":"Past Temporal Logic Temporal signals Expression syntax Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. Commonly used patterns Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#past-temporal-logic","text":"","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#temporal-signals","text":"","title":"Temporal signals"},{"location":"past_temporal_logic/#expression-syntax","text":"Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Expression syntax"},{"location":"past_temporal_logic/#commonly-used-patterns","text":"Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"Commonly used patterns"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmarking"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"python_api/","text":"Running Reelay from Python","title":"Python API"},{"location":"python_api/#running-reelay-from-python","text":"","title":"Running Reelay from Python"},{"location":"release_notes/","text":"","title":"Release Notes"}]}