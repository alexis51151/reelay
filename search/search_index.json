{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reelay Monitors Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase. Features Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line Get Started The next steps for you are to install Reelay from source or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ , Python , and the command line interface . Contribute Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Home"},{"location":"#reelay-monitors","text":"Reelay is a header-only C++ library and set of tools for system-level verification and testing of real-time systems. Reelay implements state-of-the-art runtime verification techniques to construct runtime monitors that check temporal behaviors of the system against system-level requirements. Hence, Reelay can be used to enhance rigorous systems engineering practices by formalizing and automating the assessment phase.","title":"Reelay Monitors"},{"location":"#features","text":"Formal specification of temporal properties Provably correct monitor construction from the specification Fast and frugal runtime requirement checking (very low overhead) Simple but non-restrictive user interface Available for C++, Python, and the command line","title":"Features"},{"location":"#get-started","text":"The next steps for you are to install Reelay from source or Docker image and follow through the tutorial to learn how to use Reelay monitors from C++ , Python , and the command line interface .","title":"Get Started"},{"location":"#contribute","text":"Currently Reelay does not have a contribution guideline. However, we always welcome bug reports, enhancements, and comments regarding the project. Please use the Issues page if you have a bug report, enhancement, or comment. Thanks for your interest!","title":"Contribute"},{"location":"author/","text":"Dogan Ulus Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Author"},{"location":"author/#dogan-ulus","text":"Dogan Ulus obtained his B.S. and M.S. in Electrical Engineering from the Bogazici University, Istanbul in 2011 and in 2013, respectively. He completed his Ph.D. thesis, Pattern Matching with Time: Theory and Applications , under the liberal supervision of Oded Maler in the Verimag laboratory, a leading academic institution in verification and model-based design.","title":"Dogan Ulus"},{"location":"behaviors/","text":"(Under construction)","title":"Temporal Behaviors"},{"location":"cpp_api/","text":"(Under construction)","title":"C++ API"},{"location":"docker/","text":"Running Reelay in a Docker container This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Docker Image"},{"location":"docker/#running-reelay-in-a-docker-container","text":"This document is designed for people who want to run reelay apps without installing all the dependencies on your machine. First, pull the latest docker image and run it in a container by typing: docker pull doganulus/reelay docker run -it doganulus/reelay Then you can run reelay apps inside the container. For example, rymtl 'p1 since[18:24] p2' reelay/apps/mtl/examples/2.csv --verbose 1 Note that you can install Docker engine on Ubuntu by following instructions from here if you don't have it already.","title":"Running Reelay in a Docker container"},{"location":"gs_cli/","text":"Getting Started From Terminal Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive","title":"Use Reelay from CLI"},{"location":"gs_cli/#getting-started-from-terminal","text":"Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive","title":"Getting Started From Terminal"},{"location":"gs_cpp/","text":"Getting Started From C++ Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive Reelay has been designed for efficiency and flexibility so that users can write their applications in C++ or embed formal specification monitoring into their projects easily. #include \"reelay/recipes.hpp\" The use of reelay monitors is pretty straighforward and we construct an online monitor for a past temporal logic formula as follows: auto my_monitor = reelay::past_ltl_monitor(\"grant -> once(request)\"); for (const auto &current_input : input_sequence) { my_monitor->update(current_input); // feed with current input current_output = my_monitor->output(); // obtain the current output } Since this is a property that should be true at each and every time point The ability to construct discrete and dense timed monitors from timed specifications is the main goal and feature of reelay project. We construct online monitor from such specification as follows: auto my_monitor = reelay::discrete_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); auto my_monitor = reelay::dense_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); From the online monitoring point of view, the essential difference between discrete and dense time models is the duration of updates, which is strictly one time unit for the discrete setting whereas it could be arbitrarily long or short for the dense setting. For more information, please check discrete and dense timed settings. These settings are usually called metric temporal logic (MTL) and very popular for specifiying properties of real-time/cyber-physical systems.","title":"Use Reelay from C++"},{"location":"gs_cpp/#getting-started-from-c","text":"Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive Reelay has been designed for efficiency and flexibility so that users can write their applications in C++ or embed formal specification monitoring into their projects easily. #include \"reelay/recipes.hpp\" The use of reelay monitors is pretty straighforward and we construct an online monitor for a past temporal logic formula as follows: auto my_monitor = reelay::past_ltl_monitor(\"grant -> once(request)\"); for (const auto &current_input : input_sequence) { my_monitor->update(current_input); // feed with current input current_output = my_monitor->output(); // obtain the current output } Since this is a property that should be true at each and every time point The ability to construct discrete and dense timed monitors from timed specifications is the main goal and feature of reelay project. We construct online monitor from such specification as follows: auto my_monitor = reelay::discrete_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); auto my_monitor = reelay::dense_timed<time_t>::monitor<input_t>::from_temporal_logic(\"p1 since[18:24] p2\"); From the online monitoring point of view, the essential difference between discrete and dense time models is the duration of updates, which is strictly one time unit for the discrete setting whereas it could be arbitrarily long or short for the dense setting. For more information, please check discrete and dense timed settings. These settings are usually called metric temporal logic (MTL) and very popular for specifiying properties of real-time/cyber-physical systems.","title":"Getting Started From C++"},{"location":"gs_intro/","text":"Tutorial: Introduction This initial part of the tutorial is about why we have system requirements and how to write them in the specification languages that Reelay support. The remaining parts will about how to check these specifications over temporal streams using Reelay . Let\u2019s start with an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature! An Example Feature So we want to design a feature that warns the user whenever our robot detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another tutorial. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into testable system requirements. Perhaps we would want to issue a warning after some time, say 15 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open more than 15 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our third and final requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: The next section will be about writing these requirements in a non-ambigious (and executable) specification language. Specify Requirements In this tutorial, we will use Past Temporal Logic (PTL) to specify our requirements. Temporal logics such as PTL are commonly used to describe temporal patterns over signals in a precise and non-ambigious manner. Reelay can compile PTL specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open more than 15 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in PTL: (historically[0:15](is_door_open) and not dow_suppressed) -> door_open_warning The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b](cond) tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:15](is_door_open) is true if is_door_open is always true from 15 minutes ago to now . The cheatsheet for PTL is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. door_open_warning -> historically[0:15](is_door_open) door_open_warning -> not dow_suppressed Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . door_open_warning -> not(pre(is_door_open since door_open_warning)) This specification verifies SYS-REQ-01 and each of their violations would be considered as a false positive. To conclude let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](is_door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](is_door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(is_door_open since door_open_warning)) False Positive Verify the Execution Following tutorials will explain how to check these specifications over the system behavior: Using Reelay monitors from C++ Using Reelay monitors from Python Using Reelay monitors from CLI","title":"Tutorial: Introduction"},{"location":"gs_intro/#tutorial-introduction","text":"This initial part of the tutorial is about why we have system requirements and how to write them in the specification languages that Reelay support. The remaining parts will about how to check these specifications over temporal streams using Reelay . Let\u2019s start with an example from the robotics such that we are designing a home assistant robot as our next big product. Besides we also think our customers would love our robots with a door open warning feature!","title":"Tutorial: Introduction"},{"location":"gs_intro/#an-example-feature","text":"So we want to design a feature that warns the user whenever our robot detects the entry door is left open. For the Door Open Warning (DOW) feature, there are two classes of failures, false positives (FP) and false negatives (FN). If we were more functional safety minded, there will be the assessment of the severity of each class but let's leave such aspects for another tutorial. We will simply measure the progress of development by the number of failures over some set of test cases. The next step is to analyse and break down the feature into testable system requirements. Perhaps we would want to issue a warning after some time, say 15 minutes, rather than immediately. This constitutes our first requirement expressed as follows: Requirement SYS-REQ-01: The system shall issue a warning if the entry door is left open more than 15 minutes. An important point here is that we can actually check this requirement over the behavior of the robot in such scenarios. Perhaps a spoiler but we will use Reelay monitors to check but let's finish our requirements first. Assume that we also want to give the warning once as multiple warnings for the same occasion may annoy our users. This constitutes our third and final requirement expressed as follows: Requirement SYS-REQ-02: The door should be closed before the system issues another warning. This should prevent that the warning is issuing several warnings after another, while the door is open. Now we have a set of system requirements for the DOW feature. And we may design a system whose block diagram given is below: The next section will be about writing these requirements in a non-ambigious (and executable) specification language.","title":"An Example Feature"},{"location":"gs_intro/#specify-requirements","text":"In this tutorial, we will use Past Temporal Logic (PTL) to specify our requirements. Temporal logics such as PTL are commonly used to describe temporal patterns over signals in a precise and non-ambigious manner. Reelay can compile PTL specifications into efficient runtime monitors. Let's specify! Our first requirement SYS-REQ-01 says that the system shall issue a warning if the door is open more than 15 minutes. This of course should be under understood under a condition that the warning is not suppressed as SYS-REQ-02 will require. This often goes without saying as humans can relate two requirements easily. However, when specifiying requirements for the machine, we have to be more explicit. Below is the first part of SYS-REQ-01 expressed in PTL: (historically[0:15](is_door_open) and not dow_suppressed) -> door_open_warning The implication operator -> says the right hand side must be true if the left hand side is true. The temporal operator historically[a:b](cond) tells that the condition cond must be always true between time points [now-b, now-a] . Therefore, the part historically[0:15](is_door_open) is true if is_door_open is always true from 15 minutes ago to now . The cheatsheet for PTL is available here , which includes other temporal and Boolean operators. Overall this specification verifies SYS-REQ-01 and its violation would be considered as a false negative. In plain English, the conditional connective if has sometimes a bi-directional meaning where the reverse case also goes without saying. This is also the case for SYS-REQ-01 . The remaining two specifications verify SYS-REQ-01 in a reverse way, for false positives, respectively. door_open_warning -> historically[0:15](is_door_open) door_open_warning -> not dow_suppressed Finally, the second requirement SYS-REQ-02 describes a behavior that involves slightly more complex temporal ordering of events. Here we see the use of temporal operators pre (meaning previously) and since . door_open_warning -> not(pre(is_door_open since door_open_warning)) This specification verifies SYS-REQ-01 and each of their violations would be considered as a false positive. To conclude let's tabulate our formal specifications obtained from system requirements above in a table nicely as follows: Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](is_door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](is_door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(is_door_open since door_open_warning)) False Positive","title":"Specify Requirements"},{"location":"gs_intro/#verify-the-execution","text":"Following tutorials will explain how to check these specifications over the system behavior: Using Reelay monitors from C++ Using Reelay monitors from Python Using Reelay monitors from CLI","title":"Verify the Execution"},{"location":"gs_python/","text":"Getting Started From Python Warning Reelay Python API is in its very early stage. Everthing in this page is subject to change. Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive","title":"Use Reelay from Python"},{"location":"gs_python/#getting-started-from-python","text":"Warning Reelay Python API is in its very early stage. Everthing in this page is subject to change. Requirement Specification Failure Type SYS-REQ-01 (historically[0:15](door_open) and not dow_suppressed) -> door_open_warning False Negative SYS-REQ-01 door_open_warning -> historically[0:15](door_open) False Positive SYS-REQ-01 door_open_warning -> not dow_suppressed False Positive SYS-REQ-02 door_open_warning -> not(pre(door_open since door_open_warning)) False Positive","title":"Getting Started From Python"},{"location":"install/","text":"Install Reelay C++ Library Reelay is tested on the latest Ubuntu LTS (18.04). A fresh Ubuntu installation at least requires the installation of following packages: sudo apt-get update sudo apt-get install -y libboost-all-dev Then, clone the reelay repository: git clone https://github.com/doganulus/reelay.git cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Now you can include reelay monitors in your C++ project! #include \"reelay/monitors.hpp\" Please also check the apps folder for more information on the usage. Reelay Python Package A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: make python Currently past LTL, past MTL, and past STL monitors are available from Python over discrete and dense time signals. Please check example python files . Reelay Apps The following command will compile and install command-line applications using reelay library to monitor formal specifications over CSV files: make apps sudo make apps-install Currently available applications are rymtl for past MTL specifications and rystl for past STL specifications.","title":"From Source"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#reelay-c-library","text":"Reelay is tested on the latest Ubuntu LTS (18.04). A fresh Ubuntu installation at least requires the installation of following packages: sudo apt-get update sudo apt-get install -y libboost-all-dev Then, clone the reelay repository: git clone https://github.com/doganulus/reelay.git cd reelay Since reelay is a header-only library, you only need to copy the header files into your include directory using the command: sudo make install Now you can include reelay monitors in your C++ project! #include \"reelay/monitors.hpp\" Please also check the apps folder for more information on the usage.","title":"Reelay C++ Library"},{"location":"install/#reelay-python-package","text":"A set of predefined Reelay monitors can be accessed from Python. The following command will install the reelay package in your Python environment: make python Currently past LTL, past MTL, and past STL monitors are available from Python over discrete and dense time signals. Please check example python files .","title":"Reelay Python Package"},{"location":"install/#reelay-apps","text":"The following command will compile and install command-line applications using reelay library to monitor formal specifications over CSV files: make apps sudo make apps-install Currently available applications are rymtl for past MTL specifications and rystl for past STL specifications.","title":"Reelay Apps"},{"location":"license/","text":"The Reelay project is licensed under the MPL 2.0 . The MPL 2.0 is a simple copyleft license. The MPL's \"file-level\" copyleft is designed to encourage contributors to share modifications they make to your code, while still allowing them to combine your code with code under other licenses (open or proprietary) with minimal restrictions. Please also check frequently asked questions and answers about using and distributing code under the MPL 2.0 from here .","title":"License"},{"location":"literature/","text":"Literature Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"References"},{"location":"literature/#literature","text":"Here is a list of ten papers influenced the Reelay project: Realization of events by logical nets by Irving M. Copi, Calvin C. Elgot, and Jesse B. Wright. 1958. On equations for regular languages, finite automata, and sequential networks by Janusz A. Brzozowski and Ernst Leiss. 1980. From regular expressions to deterministic automata by Gerard Berry and Ravi Sethi. 1986. Synthesizing monitors for safety properties by Klaus Havelund and Grigore Ro\u015fu. 2002. Monitoring temporal properties of continuous signals by Oded Maler and Dejan Nickovic. 2004. Timed pattern matching by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2014. Online timed pattern matching using derivatives by Dogan Ulus, Thomas Ferrere, Eugune Asarin, and Oded Maler. 2016. First-order temporal logic monitoring with BDDs by Klaus Havelund, Doron A. Peled, and Dogan Ulus. 2017. Sequential circuits from regular expressions revisited by Dogan Ulus. 2018. Online monitoring of metric temporal logic using sequential networks by Dogan Ulus. 2019.","title":"Literature"},{"location":"motivation/","text":"Why","title":"Why"},{"location":"motivation/#why","text":"","title":"Why"},{"location":"naming/","text":"Naming The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"naming/#naming","text":"The name Reelay is originated from the term \"relay circuits\" as the initial work in the project has been done for translating regular expressions into sequential circuits and thus we are LAY-ing down REs. The extra letter E is helpful in Google searches and also the project has been quickly evolved into other formalisms expressed as regular expressions and else (REE). The name is also a tribute to A Symbolic Analysis of Relay and Switching Circuits , the master's thesis of my scientific role model Claude E. Shannon.","title":"Naming"},{"location":"past_temporal_logic/","text":"Past Temporal Logic Temporal signals Expression syntax Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now. Commonly used patterns Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"PTL Cheatsheet"},{"location":"past_temporal_logic/#past-temporal-logic","text":"","title":"Past Temporal Logic"},{"location":"past_temporal_logic/#temporal-signals","text":"","title":"Temporal signals"},{"location":"past_temporal_logic/#expression-syntax","text":"Construct Syntax Examples Explanation Atomic Expressions Propositions name lights_on lights_on is a Boolean variable over time. Numerical Comparison Predicates name < const name <= const name > const name >= const speed < 30m/s temperature > 10*C speed and temperature are numerical variables over time. Custom Predicates $ fname(args...) $ my_predicate ( speed ) User defines the Boolean valued function my_predicate Boolean Expressions Negation not , ! not lights_on Conjunction and , && speed > 10m/s and speed < 30m/s Disjunction or , || Implication implies , -> lights_on implies ( speed < 30m/s) Temporal Expressions Previously pre , Y pre ( lights_on ) It is true at the current time point if lights were on in the previous time point. Sometime in the Past once , P once ( lights_on ) The expression once ( lights_on ) is true at the current time point if lights were on in some time in the past. Sometime in the Past (Bounded) once[a:b] , P[a:b] once[a:b] ( lights_on ) The expression once[a:b] ( lights_on ) is true at the current time point if lights were on in sometime between b and a time units before now. Always in the Past historically , H historically ( lights_on ) The expression historically ( lights_on ) is true at the current time point if lights were always on time in the past. Always in the Past (Bounded) historically[a:b] , H[a:b] historically[a:b] ( lights_on ) The expression historically[a:b] ( lights_on ) is true at the current time point if lights were always on between b and a time units before now. Since since , S ( speed < 30) since lights_on The expression ( speed < 30) since lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true last time. Since (Bounded) since[a:b] , S[a:b] ( speed < 30) since[a:b] lights_on The expression ( speed < 30) since[a:b] lights_on is true at the current time point if the variable speed is always less than 30 since lights_on is true sometime between b and a time units before now.","title":"Expression syntax"},{"location":"past_temporal_logic/#commonly-used-patterns","text":"Property Expression Explanation Absence After (once[0:b] Q ) -> (not P since Q ) P is false at least for b time units after Q is true. Absence Before R -> historically[0:b] (not P ) P is false at least for b time units before R is true. Absence Between ( R && ! Q && once Q ) -> (not P since Q ) P is false between R is true and then Q is true.","title":"Commonly used patterns"},{"location":"performance/","text":"Benchmark Results We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite. Discrete Time MTL Application Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Benchmarking"},{"location":"performance/#benchmark-results","text":"We use the benchmark generator timescales to benchmark the performance of reelay MTL monitoring app. For measurements, we use multitime utility. Tests are performed using a laptop computer (Intel Core i5-7200U CPU @2.50 Ghz, 8GB RAM) on Ubuntu 18.04 on WSL (Build 18362.449). The full benchmark suite of timescales can be built using the command: make timescales This command will clone timescales repository and generate the full suite.","title":"Benchmark Results"},{"location":"performance/#discrete-time-mtl-application","text":"Test command: make test_mtl_performance_discrete Performance results (real, min) of for monitoring common temporal properties over traces with a length of 1 million rows: Property/Scale 10x 100x 1000x AbsentAQ 0.834 0.828 0.830 AbsentBR 0.809 0.833 0.843 AbsentBQR 0.985 0.952 0.957 AlwaysAQ 0.827 0.815 0.814 AlwaysBR 0.785 0.790 0.793 AlwaysBQR 0.973 0.951 0.955 RecurGLB 0.754 0.698 0.702 RecurBQR 1.102 1.068 1.068 RespondGLB 1.008 0.927 0.943 RespondBQR 1.285 1.237 1.215 Multitime batch files for these tests can be found here .","title":"Discrete Time MTL Application"},{"location":"python_api/","text":"Running Reelay from Python","title":"Python API"},{"location":"python_api/#running-reelay-from-python","text":"","title":"Running Reelay from Python"},{"location":"regular_expressions/","text":"(Under construction)","title":"Regular Expressions"},{"location":"release_notes/","text":"(Under construction)","title":"Release Notes"},{"location":"sequential_networks/","text":"(Under construction)","title":"Sequential Networks"},{"location":"specification/","text":"(Under construction)","title":"Formal Specifications"},{"location":"time_models/","text":"(Under construction)","title":"Time Models"}]}